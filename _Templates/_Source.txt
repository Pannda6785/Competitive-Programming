#$ Stress
#A Matrix
  @00-1 the only one
#B Convex Hull Trick (CHT)
  @000 Standard Li Chao
  @001 Segmentated Li Chao
  @002 Standard Kinetic Tournament
  @003 Temperature-Localizing Kinetic Tournament
#C DP Optimizations
  @004 DnC
  @005 Knuth 2d1d
  @006 Knuth 1d1d
#D Graph Processings
  @007 Bridge Tree
  @008 Block Cut Tree
  @009 2-SAT
#E Flows
  @010 Max Flows
  @011 Min Cost k-Flows
  @012 Bipartite Matching (MCBM, MVC)
  @013 Flows with Demands
#F Shortest Paths and Cycle Processings
  @014 Longest Path (from 1 to n)
  @015 Negative Cycle Detecting
  @016 Shortest Cycle (Girth)
  @017 Euler Cycle
  @018 Euler Path
  @019 Hamiltonian Cycle
#G Tree
  @020 Tree in General (LCA, HLD, Euler Tour)
  @020.5 Segmented Tree
  @021 Small to Large (with one DS)
  @022 Centroid Tree
  @023 Tree Isomorphism
#H Math: Combinatorics, Number Theory, Numerics
  @024 Combinatorics
  @025 Number Theory (prime link and phi, rho's)
  @026 FFT
  @026.5 Gaussian Elimination
  @027 Chinese Remainder Theorem
  @028 Fibonacci (by doubling)
  @029 Math's note (Lucas, number of trees)
#I Geometry
  @030 General Geometry
  @031 Minkowski Sum
  @032 Near Points
  @033 Convex Hull Construction
  @034 Rectangle Union Area
#J String
  @035 Hash
  @036 Z, Pi, Manacher's
  @037 Aho Corasick (with log containers)
  @038 Suffix Automaton
  @039 Palindrome Tree
#K Mo's
  @040 Standard Mo's
  @041 Online Mo's
  @042 Mo's on Tree
#L Data Structures
  @043 Fenwick
  @044 Lazy Propagation
  @045 Implicit with Lazy
  @046 Fenwick 2D
  @047 Segment Tree 2D
  @048 Persistent Segment Tree
  @049 Sparse Table
  @050 Rollback
#M Miscellaneous
  @051 Ternary Search
  @052 Parallel Binary Search
  @053 Harmonic Knapsack with Trace

=============================================================================
#$ STRESS

#include <bits/stdc++.h>
using namespace std;

const string NAME = "test";

/*

    freopen("inp.inp", "r", stdin);
    freopen("out.out", "w", stdout);

*/

long long time() { return chrono::steady_clock::now().time_since_epoch().count(); }

mt19937_64 rng(time());

long long rand(long long l, long long r, int t = 0) {
    if (t == 0) return l + rng() % (r - l);
    if (t > 0) return max(rand(l, r), rand(l, r, t - 1));
    if (t < 0) return min(rand(l, r), rand(l, r, t + 1));
    assert(false);
    return -1;
}

void generate() {
    ofstream cout("inp.inp");

    // something

    cout.close();
}

int main() {
    int t = (int)100;
    while (t--) {
        generate();

        double tim = time();
        system((NAME + ".exe").c_str());
        tim = (time() - tim) / 1e9;
        cout << tim << '\n';

        system("Brute.exe");
        if (system("fc out.out ans.out")) {
            cout << "WRONG ANSWER!\n";
            exit(0);
        }
    }
}

=============================================================================

#A Matrix

@00-1 the only one

const int P = (int)1e9 + 7;

struct Matrix {
    int n, m;
    vector<vector<int>> a;

    Matrix(int n, int m, int val = 0) : n(n), m(m), a(n, vector<int>(m, val)) {}

    Matrix operator*(Matrix b) {
        Matrix a = *this;
        assert(a.m == b.n);
        Matrix res(a.n, b.m);
        for (int i = 0; i < a.n; i++) {
            for (int k = 0; k < a.m; k++) {
                for (int j = 0; j < b.m; j++) {
                    res.a[i][j] = (res.a[i][j] + 1LL * a.a[i][k] * b.a[k][j]) % P;
                }
            }
        }
        return res;
    }

    Matrix I(int n) {
        Matrix res(n, n);
        for (int i = 0; i < n; i++) {
            res.a[i][i] = 1;
        }
        return res;
    }

    Matrix operator^(long long b) {
        Matrix a = *this;
        assert(a.n == a.m);
        Matrix res = I(a.n);
        for (; b; b >>= 1, a = a * a) {
            if (b & 1) {
                res = res * a;
            }
        }
        return res;
    }

    void print() {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                cout << a[i][j] << ' ';
            }
            cout << '\n';
        }
    }
};

#B Convex Hull Trick (CHT)

@000 Standard Li Chao: line add min get, returns INF if no line added

template <class T>
struct LiChao {
    const T INF = numeric_limits<T>::max() / 2;

    int C;
    vector<T> dom;
    vector<array<T, 2>> first;
    vector<int> label;

    T f(array<T, 2> p, int x) {
        return p[0] * dom[x] + p[1];
    }

    LiChao(vector<T> _dom) : dom(_dom) {
        sort(dom.begin(), dom.end());
        dom.resize(unique(dom.begin(), dom.end()) - dom.begin());
        C = dom.size();
        first.resize(4 * C, make_pair(0, INF));
        label.resize(4 * C, -1);
    }

    void add(T a, T b, int lab) {
        array<T, 2> p{a, b};
        int idx = 0, l = 0, r = C;
        while (l < r) {
            int m = (l + r) >> 1;
            bool doml = f(p, l) < f(first[idx], l);
            bool domm = f(p, m) < f(first[idx], m);
            if (domm) swap(p, first[idx]), swap(label[idx], lab);
            if (l + 1 == r) break;
            if (doml != domm) idx = 2 * idx + 1, r = m;
            else idx = 2 * idx + 2, l = m;
        }
    }

    pair<T, int> getMin(T x) {
//        x -= 1e-9;
        x = lower_bound(dom.begin(), dom.end(), x) - dom.begin();
        T mn = INF;
        int lab = -1;
        int idx = 0, l = 0, r = C;
        while (l < r) {
            if (f(first[idx], x) < mn) mn = f(first[idx], x), lab = label[idx];
            if (l + 1 == r) break;
            int m = (l + r) >> 1;
            if (x < m) idx = 2 * idx + 1, r = m;
            else idx = 2 * idx + 2, l = m;
        }
        return make_pair(mn, lab);
    }
};

@001 Segmentated Li Chao: segment add min get, returns INF if no segment presents at x

const long long INF = (long long)4e18;

typedef complex<long long> point;
long long dot(point a, point b) {
    return (conj(a) * b).real();
}

struct Segment {
    int l, r;
    point p;
};

struct LiChao { // [l, r]
    int C;
    vector<int> dom;
    vector<point> st;

    LiChao(vector<int> _dom) : dom(_dom) {
        sort(dom.begin(), dom.end());
        dom.resize(unique(dom.begin(), dom.end()) - dom.begin());
        C = dom.size();
        st.resize(4 * C, point(0, INF));
    }

    long long f(point p, int x) {
        return dot(p, point(dom[x], 1));
    }

    void add(point p, int idx, int l, int r) {
        int m = (l + r) >> 1;
        bool domm = f(p, m) < f(st[idx], m);
        bool doml = f(p, l) < f(st[idx], l);
        if (domm) swap(p, st[idx]);
        if (l < r) {
            int m = (l + r) >> 1;
            if (domm != doml) add(p, 2 * idx + 1, l, m);
            else add(p, 2 * idx + 2, m + 1, r);
        }
    }

    void decompose(int ql, int qr, point p, int idx, int l, int r) {
        if (dom[r] < ql || qr < dom[l]) return;
        if (ql <= dom[l] && dom[r] <= qr) {
            add(p, idx, l, r);
            return;
        }
        int m = (l + r) >> 1;
        decompose(ql, qr, p, 2 * idx + 1, l, m);
        decompose(ql, qr, p, 2 * idx + 2, m + 1, r);
    }

    long long favor;
    void touch(int x, int idx, int l, int r) {
        favor = min(favor, f(st[idx], x));
        if (l < r) {
            int m = (l + r) >> 1;
            if (x <= m) touch(x, 2 * idx + 1, l, m);
            else touch(x, 2 * idx + 2, m + 1, r);
        }
    }

    void add(Segment seg) {
        decompose(seg.l, seg.r, seg.p, 0, 0, C - 1);
    }

    long long getMin(int x) {
        x = lower_bound(dom.begin(), dom.end(), x) - dom.begin();
        favor = INF;
        touch(x, 0, 0, C - 1);
        return favor;
    }
};

@002 Standard Kinetic Tournament: n functions y=0x+0 by default, modifiable at any time, queries for maximum y, queries must strictly (fix the assert otherwise) increase by x

const long long INF = (long long)4e18;

int sgn(long long x) {
    if (x == 0) return 0;
    return x > 0 ? +1 : -1;
}

long long rationalFloor(long long a, long long b) {
    return a / b - (a % b != 0 && sgn(a) != sgn(b));
}

struct KineticTournament {
    struct Node {
        int i;
        int a;
        long long b;
        long long melting_time;
        Node() {}
        Node(int i, int a, long long b, long long melting_time) : i(i), a(a), b(b), melting_time(melting_time) {}
        long long operator()(int t) { return 1LL * a * t + b; }
    };

    int n, t;
    vector<Node> nodes;

    KineticTournament(int n, int t0) : n(n), t(t0), nodes(4 * n, Node(-1, 0, 0, INF)) {}

    Node merge(Node x, Node y) {
        if (x(t) < y(t)) swap(x, y);
        Node res = x;
        long long xy_melting_time = x.a == y.a ? INF : rationalFloor(y.b - x.b, x.a - y.a) + 1;
        if (xy_melting_time <= t) xy_melting_time = INF;
        res.melting_time = min({ x.melting_time, y.melting_time, xy_melting_time });
        return res;
    }

    void modify(int i, int a, long long b, int idx, int l, int r) {
        if (l + 1 == r) {
            nodes[idx] = Node(i, a, b, INF);
        } else {
            int m = (l + r) >> 1;
            if (i < m) modify(i, a, b, 2 * idx + 1, l, m);
            else modify(i, a, b, 2 * idx + 2, m, r);
            nodes[idx] = merge(nodes[2 * idx + 1], nodes[2 * idx + 2]);
        }
    }

    void melt(int idx, int l, int r) {
        if (t < nodes[idx].melting_time) return;
        int m = (l + r) >> 1;
        melt(2 * idx + 1, l, m);
        melt(2 * idx + 2, m, r);
        nodes[idx] = merge(nodes[2 * idx + 1], nodes[2 * idx + 2]);
    }

    void modify(int i, int a, long long b) { modify(i, a, b, 0, 0, n); }
    void heaten(int t) { assert(t > this->t); this->t = t; melt(0, 0, n); }
    Node winner() { return nodes[0]; }
};

@003 Temperature-Localizing Kinetic Tournament: same notes as standard KT, node localizes temperature, laziable

const long long INF = (long long)4e18;

int sgn(long long x) {
    if (x == 0) return 0;
    return x > 0 ? +1 : -1;
}

long long rationalFloor(long long a, long long b) {
    return a / b - (a % b != 0 && sgn(a) != sgn(b));
}

struct Tournament {
    struct Node {
        long long a, b;
        int t, dt;
        long long melting_dt;
        Node() {}
        Node(long long a, long long b, int t) : a(a), b(b), t(t), dt(0), melting_dt(INF) {}
        long long operator*() { return a * t + b; }
        Node operator+(Node y) {
            Node x = *this;
            if (*x < *y) swap(x, y);
            long long xy_melting_dt = x.a == y.a ? INF : rationalFloor(-(x.a * x.t + x.b - y.a * y.t - y.b), x.a - y.a);
            xy_melting_dt = xy_melting_dt < 0 ? INF : xy_melting_dt + 1;
            Node res = x;
            res.melting_dt = min({xy_melting_dt, x.melting_dt, y.melting_dt});
            res.dt = 0;
            return res;
        }
    };

    int n;
    vector<Node> nodes;

    Tournament(int n) : n(n), nodes(4 * n, Node(0, 0, 0)) {}

    void apply(int idx, int dt) {
        nodes[idx].t += dt;
        nodes[idx].dt += dt;
        nodes[idx].melting_dt -= dt;
        if (nodes[idx].melting_dt <= 0) {
            down(idx);
            nodes[idx] = nodes[2 * idx + 1] + nodes[2 * idx + 2];
        }
    }

    void down(int idx) {
        apply(2 * idx + 1, nodes[idx].dt);
        apply(2 * idx + 2, nodes[idx].dt);
        nodes[idx].dt = 0;
    }

    void modify(int i, long long a, long long b, int t, int idx, int l, int r) {
        if (l + 1 == r) {
            nodes[idx] = Node(a, b, t);
        } else {
            down(idx);
            int m = (l + r) >> 1;
            if (i < m) modify(i, a, b, t, 2 * idx + 1, l, m);
            else modify(i, a, b, t, 2 * idx + 2, m, r);
            nodes[idx] = nodes[2 * idx + 1] + nodes[2 * idx + 2];
        }
    }

    void modify(int i, long long a, long long b, int t) { modify(i, a, b, t, 0, 0, n); }
    void heaten(int dt) { apply(0, dt); }
    Node winner() { return nodes[0]; }
};

#C DP Optimizations

@004 DnC: dp(t, i) = min(dp(t - 1, j) + cost[j, i) | j < i) where i is the length of prefix

{
    vector<long long> prev(n + 1, INF); // base case
    prev[0] = 0; // base case
    vector<long long> dp(n + 1);

    function<void(int, int, int, int)> compute = [&](int l, int r, int optl, int optr) {
        if (l > r) return;
        int m = (l + r) >> 1;
        dp[m] = INF;
        int opt = optl;
        for (int i = optl; i <= min(optr, m); i++) {
            if (prev[i] + cost(i, m) < dp[m]) {
                dp[m] = prev[i] + cost(i, m);
                opt = i;
            }
        }
        compute(l, m - 1, optl, opt);
        compute(m + 1, r, opt, optr);
    };

    for (int i = 0; i < k; i++) {
        compute(0, n, 0, n);
        prev = dp;
    }

    cout << dp[n] << '\n';
}

@005 Knuth 2d1d: dp[l, r) = min(dp[l, m) + dp[m, r) + cost[l, r))

{
    vector<vector<long long>> dp(n, vector<long long>(n + 1, INF));
    vector<vector<int>> opt(n, vector<int>(n + 1, INF));
    for (int i = 0; i < n; i++) {
        dp[i][i + 1] = 0; // base case
        opt[i][i + 1] = i;
    }
    for (int l = n - 1; l >= 0; l--) {
        for (int r = l + 2; r <= n; r++) {
            int optl = opt[l][r - 1];
            int optr = opt[l + 1][r];
            for (int m = optl; m <= optr; m++) {
                if (dp[l][m] + dp[m][r] + cost(l, r) < dp[l][r]) {
                    dp[l][r] = dp[l][m] + dp[m][r] + cost(l, r);
                    opt[l][r] = m;
                }
            }
        }
    }
    cout << dp[0][n] << '\n';
}

@006 Knuth 1d1d: dp(i) = min(dp(j < i) + cost(j, i)) where i is prefix ending at position i

{
    vector<long long> dp(n);
    dp[0] = 0; // base case
    deque<array<int, 2>> dq = { {0, 1} }; // x and from where x applies

    for (int i = 1; i < n; i++) {
        if (dq.size() >= 2 && dq[1][1] == i) dq.pop_front(); // the second element in dq takes over

        int j = dq.front()[0];
        dp[i] = dp[j] + cost(j, i);

        if (i == n - 1) break; // from here computes from where i applies

        while (!dq.empty()) {
            int j = dq.back()[0];
            int k = max(i + 1, dq.back()[1]);
            if (dp[i] + cost(i, k) < dp[j] + cost(j, k)) { // dq's back prefers i over its current match
                dq.pop_back();
                continue;
            }
            break;
        }

        if (dq.empty()) {
            dq.push_back({i, i + 1});
        } else {
            int j = dq.back()[0];
            int l = max(i + 1, dq.back()[1]), r = n - 1;
            while (l < r) {
                int m = (l + r) >> 1;
                if (dp[i] + cost(i, m) < dp[j] + cost(j, m)) {
                    r = m;
                } else {
                    l = m + 1;
                }
            }
            if (dp[i] + cost(i, l) < dp[j] + cost(j, l)) {
                dq.push_back({i, l});
            }
        }
    }

    cout << dp[n - 1] << '\n';
}

#D Graph Processings

@007 Bridge Tree:

struct BridgeTree { // assumes full connectivity, multi-edge and self-loop ok
    vector<vector<int>> bt;
    vector<int> comp;

    BridgeTree(int n, vector<vector<int>> &adj) : comp(n, -1) {
        vector<int> num(n, -1), low(n);
        int tim = 0;
        vector<int> stk;
        int id = 0;

        function<void(int, int)> dfs = [&](int u, int p) {
            num[u] = low[u] = tim++;
            stk.push_back(u);
            bool backed = false;
            for (int v : adj[u]) {
                if (v == p && !backed) {
                    backed = true;
                    continue;
                }
                if (num[v] == -1) {
                    dfs(v, u);
                    low[u] = min(low[u], low[v]);
                } else {
                    low[u] = min(low[u], num[v]);
                }
            }
            if (num[u] == low[u]) {
                int v;
                bt.emplace_back();
                do {
                    v = stk.back();
                    stk.pop_back();
                    comp[v] = id;
                    for (int w : adj[v]) {
                        if (comp[w] != -1 && comp[w] != comp[v]) {
                            bt[comp[w]].push_back(comp[v]);
                            bt[comp[v]].push_back(comp[w]);
                        }
                    }
                } while (v != u);
                id++;
            }
        };

        dfs(0, -1);
    }

    int size() { return bt.size(); }
    vector<vector<int>> getBT() { return bt; }
};

@008 Block Cut Tree:

struct BlockCutTree { // assumes full connectivity, multi-edge and self-loop ok
    vector<vector<int>> bct; // the tree, virtual nodes are numbered from n onward

    BlockCutTree(int n, vector<vector<int>> &adj) : bct(n) {
        vector<int> num(n, -1), low(n);
        int tim = 0;
        vector<int> stk;
        int id = n;

        function<void(int, int)> dfs = [&](int u, int p) {
            num[u] = low[u] = tim++;
            stk.push_back(u);
            bool backed = false;
            for (int v : adj[u]) {
                if (v == p && !backed) {
                    backed = true;
                    continue;
                }
                if (num[v] == -1) {
                    dfs(v, u);
                    low[u] = min(low[u], low[v]);
                    if (low[v] >= num[u]) {
                        bct.emplace_back();
                        int w;
                        do {
                            w = stk.back();
                            stk.pop_back();
                            bct[w].push_back(id);
                            bct[id].push_back(w);
                        } while (w != v);
                        bct[u].push_back(id);
                        bct[id].push_back(u);
                        id++;
                    }
                } else {
                    low[u] = min(low[u], num[v]);
                }
            }
        };

        dfs(0, -1);
    }

    int size() { return bct.size(); }
    vector<vector<int>> getBCT() { return bct; }
    vector<int> neighbour(int u) { return bct[u]; }
};

@009 2-SAT:

struct TwoSAT {
    int n; // number of variables
    vector<vector<int>> adj;

    TwoSAT(int n) : n(n), adj(n + n) {}

    void add(int sgn_u, int u, int sgn_v, int v) { // sgn = -1 if negating, +1 otherwise, add a condition (sgn_u * u OR sgn_v * v)
        u = sgn_u == +1 ? 2 * u : 2 * u + 1;
        v = sgn_v == +1 ? 2 * v : 2 * v + 1;
        adj[u ^ 1].push_back(v);
        adj[v ^ 1].push_back(u);
    }

    bool solve(vector<int> &solution) {
        solution.resize(n);

        vector<int> num(n + n, -1), low(n + n);
        int tim = 0;
        vector<int> stk;
        vector<bool> in_stk(n + n, false);
        vector<int> comp(n + n, -1);
        int cnt = 0;

        function<void(int)> dfs = [&](int u) {
            num[u] = low[u] = tim++;
            stk.push_back(u);
            in_stk[u] = true;
            for (int v : adj[u]) {
                if (num[v] == -1) {
                    dfs(v);
                    low[u] = min(low[u], low[v]);
                } else if (in_stk[v]) {
                    low[u] = min(low[u], num[v]);
                }
            }
            if (num[u] == low[u]) {
                int v;
                do {
                    v = stk.back();
                    stk.pop_back();
                    in_stk[v] = false;
                    comp[v] = cnt;
                } while (v != u);
                cnt++;
            }
        };

        for (int u = 0; u < n + n; u++) {
            if (num[u] == -1) {
                dfs(u);
            }
        }

        for (int i = 0; i < n; i++) {
            int u = 2 * i;
            int nu = 2 * i + 1;
            if (comp[u] == comp[nu]) return false;
            solution[i] = comp[u] < comp[nu] ? +1 : -1;
        }

        return true;
    }
};

#E Flows

@010 Max Flow:

template <class T>
struct Flow {
    const T INF = numeric_limits<T>::max() / 2;
    struct Edge {
        int u, v;
        T capacity, flowed;
    };

    int n, m;
    vector<Edge> edges;
    vector<vector<int>> adj;
    vector<int> layer;
    vector<int> ptr;

    Flow(int n) : n(n), m(0), adj(n), layer(n), ptr(n) {}

    int addEdge(int u, int v, T capacity) {
        adj[u].push_back(m);
        edges.push_back({ u, v, capacity, 0 });
        adj[v].push_back(m + 1);
        edges.push_back({ v, u, 0, 0 });
        m += 2;
        return m - 2;
    }

    bool bfs(int s, int t) {
        fill(layer.begin(), layer.end(), -1);
        queue<int> que;
        layer[s] = 0;
        que.push(s);
        while (!que.empty()) {
            int u = que.front();
            que.pop();
            for (int i : adj[u]) {
                auto [_u, v, capacity, flowed] = edges[i];
                if (capacity - flowed < 1) continue;
                if (layer[v] != -1) continue;
                layer[v] = layer[u] + 1;
                que.push(v);
            }
        }
        return layer[t] != -1;
    }

    T dfs(int u, int t, T pushed) {
        if (u == t) {
            return pushed;
        }
        for (int &ii = ptr[u]; ii < (int)adj[u].size(); ii++) {
            int i = adj[u][ii];
            auto [_u, v, capacity, flowed] = edges[i];
            if (capacity - flowed < 1) continue;
            if (layer[v] != layer[u] + 1) continue;
            T push = min(pushed, capacity - flowed);
            push = dfs(v, t, push);
            if (push > 0) {
                edges[i].flowed += push;
                edges[i ^ 1].flowed -= push;
                return push;
            }
        }
        return 0;
    }

    T maxFlow(int s, int t) {
        T flowed = 0;
        while (bfs(s, t)) {
            fill(ptr.begin(), ptr.end(), 0);
            while (T newly_flowed = dfs(s, t, INF)) {
                flowed += newly_flowed;
            }
        }
        return flowed;
    }

    vector<int> minCut(int s, int t) {
        maxFlow(s, t);
        vector<bool> vis(n, false);
        queue<int> que;
        vis[s] = true;
        que.push(s);
        while (!que.empty()) {
            int u = que.front();
            que.pop();
            for (int i : adj[u]) {
                auto [_u, v, capacity, flow] = edges[i];
                if (capacity - flow < 1) continue;
                if (!vis[v]) {
                    vis[v] = true;
                    que.push(v);
                }
            }
        }
        vector<int> res;
        for (int i = 0; i < m; i += 2) {
            auto [u, v, capacity, flowed] = edges[i];
            if (capacity - flowed < 1 && vis[u] && !vis[v]) {
                res.push_back(i);
            }
        }
        return res;
    }
};

@011 Min Cost k-Flows:

*Bellman's approach

template <class T>
struct Flow {
    const T INF = numeric_limits<T>::max() / 2;

    struct Edge {
        int u, v;
        T capacity, cost, flowed;
    };
    int n, m;
    vector<Edge> edges;
    vector<vector<int>> adj;
    vector<int> par;

    Flow(int n) : n(n), m(0), adj(n), par(n) {}

    int addEdge(int u, int v, T capacity, T cost) {
        adj[u].push_back(m);
        edges.push_back({ u, v, capacity, cost, 0 });
        adj[v].push_back(m + 1);
        edges.push_back({ v, u, 0, -cost, 0 });
        m += 2;
        return m - 2;
    }

    T bfs(int s, int t) {
        fill(par.begin(), par.end(), -1);
        vector<T> dist(n, -1);
        queue<int> que;
        vector<bool> in_queue(n, false);
        dist[s] = 0;
        que.push(s);
        in_queue[s] = true;
        while (!que.empty()) {
            int u = que.front();
            que.pop();
            in_queue[u] = false;
            for (int i : adj[u]) {
                auto [_u, v, capacity, cost, flowed] = edges[i];
                if (capacity - flowed < 1) continue;
                if (dist[v] == -1 || dist[u] + cost < dist[v]) {
                    dist[v] = dist[u] + cost;
                    par[v] = i;
                    if (!in_queue[v]) {
                        que.push(v);
                        in_queue[v] = true;
                    }
                }
            }
        }
        return dist[t];
    }

    T minCostKFlow(int s, int t, T k) {
        T min_cost = 0;
        while (k > 0) {
            T cost = bfs(s, t);
            if (cost == -1) break;

            T push = k;

            int v = t;
            while (par[v] != -1) {
                int i = par[v];
                auto [u, _v, capacity, cost, flowed] = edges[i];
                push = min(push, capacity - flowed);
                v = u;
            }

            v = t;
            while (par[v] != -1) {
                int i = par[v];
                auto [u, _v, capacity, cost, flowed] = edges[i];
                edges[i].flowed += push;
                edges[i ^ 1].flowed -= push;
                v = u;
            }

            min_cost += cost * push;
            k -= push;
        }
        if (k > 0) return -1;
        return min_cost;
    }
};

*Dinitz's approach

template <class Tcapa, class Tcost>
struct Flows {
    const Tcapa INFcapa = numeric_limits<Tcapa>::max() / 2;
    const Tcost INFcost = numeric_limits<Tcost>::max() / 2;
    struct Edge {
        int u, v;
        Tcapa capacity;
        Tcost cost;
        Tcapa flowed;
        Edge(int u, int v, Tcapa capacity, Tcost cost, Tcapa flowed) : u(u), v(v), capacity(capacity), cost(cost), flowed(flowed) {}
    };

    int n, m;
    vector<Edge> edges;
    vector<vector<int>> adj;
    vector<Tcost> dist;
    vector<int> ptr;

    Flows(int n) : n(n), m(0), adj(n), dist(n), ptr(n) {}

    int addEdge(int u, int v, Tcapa capacity, Tcost cost) {
        edges.push_back(Edge(u, v, capacity, cost, 0));
        edges.push_back(Edge(v, u, 0, -cost, 0));
        adj[u].push_back(m);
        adj[v].push_back(m + 1);
        m += 2;
        return m - 2;
    }

    bool dijkstra(int s, int t) {
        fill(dist.begin(), dist.end(), -1);
        priority_queue<pair<Tcost, int>, vector<pair<Tcost, int>>, greater<>> pq;
        dist[s] = 0;
        pq.push({dist[s], s});
        while (!pq.empty()) {
            auto [d, u] = pq.top();
            pq.pop();
            if (d != dist[u]) continue;
            for (int i : adj[u]) {
                auto [_u, v, capacity, cost, flowed] = edges[i];
                if (capacity - flowed == 0) continue;
                if (dist[v] == -1 || dist[u] + cost < dist[v]) {
                    dist[v] = dist[u] + cost;
                    pq.push({dist[v], v});
                }
            }
        }
        return dist[t] != -1;
    }

    Tcapa dfs(int u, int t, Tcapa pushed) {
        if (u == t || pushed == 0) {
            return pushed;
        }
        for (int &ii = ptr[u]; ii < adj[u].size(); ) {
            int i = adj[u][ii++];
            auto [_u, v, capacity, cost, flowed] = edges[i];
            if (capacity - flowed == 0) continue;
            if (dist[v] != dist[u] + cost) continue;
            Tcapa push = min(pushed, capacity - flowed);
            push = dfs(v, t, push);
            if (push) {
                edges[i].flowed += push;
                edges[i ^ 1].flowed -= push;
                return push;
            }
        }
        return 0;
    }

    Tcost minCostKFlows(int s, int t) {
        Tcost min_cost = 0;
        while (dijkstra(s, t)) {
            fill(ptr.begin(), ptr.end(), 0);
            while (Tcapa flowed = dfs(s, t, INFcapa)) {
                min_cost += dist[t] * flowed;
            }
        }
        return min_cost;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout << setprecision(15) << fixed;

    int n, a, b;
    cin >> n >> a >> b;
    vector<int> p(n), u(n);
    for (int i = 0; i < n; i++) {
        double x;
        cin >> x;
        p[i] = x * 1000000;
    }
    for (int i = 0; i < n; i++) {
        double x;
        cin >> x;
        u[i] = x * 1000000;
    }

    long long res = 0;

    for (int ab = 0; ab <= min(a, b); ab++) {
        Flows<int, long long> flows(n + 3 + 2);
        int source = n + 3, sink = source + 1;
        int A = n, B = n + 1, AB = n + 2;
        flows.addEdge(source, A, a - ab, 0);
        flows.addEdge(source, B, b - ab, 0);
        flows.addEdge(source, AB, ab, 0);
        for (int i = 0; i < n; i++) {
            flows.addEdge(i, sink, 1, 0);
            flows.addEdge(A, i, 1, -p[i]);
            flows.addEdge(B, i, 1, -u[i]);
            flows.addEdge(AB, i, 1, -(p[i] + u[i] - p[i] / 1000 * u[i] / 1000));
        }
        res = max(res, -flows.minCostKFlows(source, sink));
    }

    cout << (double(res) / 1000000) << '\n';
}

@012 Bipartite Matching: Maximum Cardinality Bipartite Matching (MCBM) and Minimum Vertex Cover (MVC):

struct BipartiteMatching {
    int n;
    vector<vector<int>> adj;

    BipartiteMatching(int n) : n(n), adj(n) {}

    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    vector<array<int, 2>> getMCBM() {
        vector<int> match(n, -1);
        vector<int> vis(n, -1);
        int ite = 0;
        function<bool(int)> dfs = [&](int u) {
            if (vis[u] == ite) return false;
            vis[u] = ite;
            for (int v : adj[u]) {
                if (match[v] == -1 || dfs(match[v])) {
                    match[v] = u;
                    match[u] = v;
                    return true;
                }
            }
            return false;
        };
        for (bool run = true; run; ) {
            run = false;
            for (int u = 0; u < n; u++) {
                if (match[u] == -1) {
                    run |= dfs(u);
                }
            }
            ite++;
        }
        vector<array<int, 2>> res;
        for (int u = 0; u < n; u++) {
            if (match[u] != -1 && match[u] > u) {
                res.push_back({ u, match[u] });
            }
        }
        return res;
    }

    /*
    Minimum Vertex Cover (MVC)
    - Give orientation to edges, unmatched edges go left to right, matched edges go right to left.
    - DFS from unmatched nodes of left side.
    - MVC are unvisited nodes of left side, and visited nodes of right side.
    */
    vector<int> getMVC() {
        vector<array<int, 2>> matched_edges = getMCBM();
        vector<int> color(n, -1);
        function<void(int)> paint = [&](int u) {
            for (int v : adj[u]) {
                if (color[v] == -1) {
                    color[v] = color[u] ^ 1;
                    paint(v);
                }
            }
        };
        for (int u = 0; u < n; u++) {
            if (color[u] == -1) {
                color[u] = 0;
                paint(u);
            }
        }
        vector<int> match(n, -1);
        for (array<int, 2> e : matched_edges) {
            int u = e[0], v = e[1];
            match[u] = v;
            match[v] = u;
        }
        vector<bool> vis(n, false);
        function<void(int)> dfs = [&](int u) {
            vis[u] = true;
            for (int v : adj[u]) {
                if (v == match[u]) continue;
                if (vis[v]) continue;
                vis[v] = true;
                if (!vis[match[v]]) dfs(match[v]);
            }
        };
        for (int u = 0; u < n; u++) {
            if (color[u] == 0 && match[u] == -1 && !vis[u]) {
                dfs(u);
            }
        }
        vector<int> res;
        for (int u = 0; u < n; u++) {
            if (color[u] == 0) {
                if (!vis[u]) res.push_back(u);
            } else {
                if (vis[u]) res.push_back(u);
            }
        }
        return res;
    }
};

@013 Flows with Demands:

struct FlowWithDemand {
    int n, s, t;
    Flow flow;
    int virtual_s, virtual_t;
    long long demand_sum = 0;
    int i;

    FlowWithDemand(int n, int s, int t, vector<array<int, 4>> edges) : n(n), s(s), t(t), flow(n + 2), virtual_s(n), virtual_t(n + 1) {
        i = flow.addEdge(t, s, INF);
        for (auto [u, v, capacity, demand] : edges) {
            flow.addEdge(u, v, capacity - demand);
            flow.addEdge(u, virtual_t, demand);
            flow.addEdge(virtual_s, v, demand);
            demand_sum += demand;
        }
    }

    bool ok(int bound) {
        flow.clearFlow();
        flow.edges[i].capacity = bound;
        return flow.maxFlow(virtual_s, virtual_t) == demand_sum;
    }

    int minFlow() {
        int l = 1, r = demand_sum + 10;
        while (l < r) {
            int m = (l + r) >> 1;
            if (ok(m)) {
                r = m;
            } else {
                l = m + 1;
            }
        }
        if (!ok(l)) return -1;
        for (auto [u, v, capacity, flowed] : flow.edges) {
            if (capacity > 0 && u == t && v == s) {
                return flowed;
            }
        }
        return -1;
    }

    vector<Flow::Edge> edges() {
        return flow.edges;
    }
};

#F Shortest Paths and Cycle Processings

@014 Longest Path (using Bellman): directed weighted graph, longest path from 1 to n, or determine arbitrary large

const long long INF = 3e18;

int main() {
    int n, m;
    cin >> n >> m;

    vector<array<int, 3>> edges(m);
    vector<vector<int>> adj(n);
    for (int i = 0; i < m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--;
        v--;
        edges[i] = { u, v, w };
        adj[v].push_back(u);
    }

    vector<long long> dist(n, -INF);
    dist[0] = 0;
    int ite = 0;
    while (ite < n - 1) {
        bool run = false;
        ite++;
        for (array<int, 3> e : edges) {
            int u = e[0], v = e[1], w = e[2];
            if (dist[u] == -INF) continue;
            if (dist[u] + w > dist[v]) {
                run = true;
                dist[v] = dist[u] + w;
            }
        }
        if (!run) break;
    }

    vector<bool> bad(n, false);
    for (array<int, 3> e : edges) {
        int u = e[0], v = e[1], w = e[2];
        if (dist[u] == -INF) continue;
        if (dist[u] + w > dist[v]) {
            bad[v] = true;
        }
    }

    queue<int> que;
    vector<bool> vis(n, false);
    vis[n - 1] = true;
    que.push(n - 1);
    while (!que.empty()) {
        int u = que.front();
        que.pop();
        if (bad[u]) {
            cout << -1 << '\n';
            return 0;
        }
        for (int v : adj[u]) {
            if (!vis[v]) {
                vis[v] = true;
                que.push(v);
            }
        }
    }

    cout << dist[n - 1] << '\n';
}

@015 Negative Cycle Detecting (using SPFA): directed graph

const long long INF = 3e18;

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<array<int, 2>>> adj(n);
    for (int i = 0; i < m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        u--;
        v--;
        adj[u].push_back({ v, w });
    }

    vector<long long> dist(n);
    vector<int> par(n);
    queue<int> que;
    vector<bool> in_queue(n);

    for (int u = 0; u < n; u++) {
        dist[u] = 0;
        par[u] = -1;
        que.push(u);
        in_queue[u] = true;
    }

    auto detect = [&]() {
        vector<bool> vis(n, false);
        vector<bool> on_stk(n, false);
        function<void(int)> dfs = [&](int u) {
            vis[u] = true;
            on_stk[u] = true;
            int v = par[u];
            if (v != -1) {
                if (!vis[v]) {
                    dfs(v);
                } else if (on_stk[v]) {
                    cout << "YES\n";
                    vector<int> key = { u };
                    while (v != u) {
                        key.push_back(v);
                        v = par[v];
                    }
                    key.push_back(u);
                    reverse(key.begin(), key.end());
                    for (int x : key) cout << x + 1 << ' ';
                    cout << '\n';
                    exit(0);
                }
            }
            on_stk[u] = false;
        };
        for (int s = 0; s < n; s++) {
            if (!vis[s]) {
                dfs(s);
            }
        }
    };

    int ite = 0;
    while (!que.empty()) {
        int u = que.front();
        que.pop();
        in_queue[u] = false;

        for (auto [v, w] : adj[u]) {
            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                par[v] = u;
                if (!in_queue[v]) {
                    que.push(v);
                    in_queue[v] = true;
                }
                if (++ite == n) {
                    ite = 0;
                    detect();
                }
            }
        }
    }

    detect();
    cout << "NO\n";
}

@016 Shortest Cycle (Girth):

const int INF = 1e9;

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<int>> adj(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--;
        v--;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    int ans = INF;
    for (int s = 0; s < n; s++) {
        vector<int> dist(n, -1);
        vector<int> par(n, -1);
        queue<int> que;
        dist[s] = 0;
        que.push(s);
        while (!que.empty()) {
            int u = que.front();
            que.pop();
            for (int v : adj[u]) {
                if (v == par[u]) continue;
                if (dist[v] == -1) {
                    dist[v] = dist[u] + 1;
                    par[v] = u;
                    que.push(v);
                } else {
                    ans = min(ans, dist[u] + dist[v] + 1);
                }
            }
        }
    }

    ans == INF ? cout << -1 << '\n' : cout << ans << '\n';
}

@017 Euler Cycle: undirected

void gg() {
    cout << "IMPOSSIBLE\n";
    exit(0);
}

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<array<int, 2>>> adj(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--;
        v--;
        adj[u].push_back({ v, i });
        adj[v].push_back({ u, i });
    }

    for (int u = 0; u < n; u++) {
        if ((int)adj[u].size() % 2 == 1) gg();
    }

    vector<bool> used(m, false);
    vector<int> key;

    function<void(int)> dfs = [&](int u) {
        while (!adj[u].empty()) {
            auto [v, i] = adj[u].back();
            adj[u].pop_back();
            if (used[i]) continue;
            used[i] = true;
            dfs(v);
            key.push_back(u);
        }
    };

    dfs(0);
    if ((int)key.size() != m) gg();
    for (int i = 0; ; i++) {
        if (key[i] == 0) {
            rotate(key.begin(), key.begin() + i, key.end());
            break;
        }
    }
    key.push_back(key.front());
    for (int x : key) {
        cout << x + 1 << ' ';
    }
    cout << '\n';
}

@018 Euler Path: directed

void gg() {
    cout << "IMPOSSIBLE\n";
    exit(0);
}

int main() {
    int n, m;
    cin >> n >> m;

    vector<vector<int>> adj(n);
    vector<int> in(n, 0), out(n, 0);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--;
        v--;
        adj[u].push_back(v);
        out[u]++;
        in[v]++;
    }

    if (out[0] != in[0] + 1 || out[n - 1] + 1 != in[n - 1]) gg();
    for (int u = 1; u < n - 1; u++) {
        if (out[u] != in[u]) gg();
    }

    vector<int> key;

    function<void(int)> dfs = [&](int u) {
        while (!adj[u].empty()) {
            int v = adj[u].back();
            adj[u].pop_back();
            dfs(v);
            key.push_back(u);
        }
    };
    dfs(0);

    if (key.size() != m) gg();

    reverse(key.begin(), key.end());
    key.push_back(n - 1);
    for (int x : key) {
        cout << x + 1 << ' ';
    }
    cout << '\n';
}

@019 Hamiltonian Cycle: undirected

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
bool findHamiltonian(int n, vector<vector<int>> adj, vector<int> &solution) {
    int ite = 100;
    while (ite--) {
        vector<int> deg(n);
        for (int i = 0; i < n; i++) {
            shuffle(adj[i].begin(), adj[i].end(), rng);
            deg[i] = adj[i].size();
        }
        deg[0] = 1e9;
        int u = 0;
        vector<int> ans = { u };
        for (int i = 1; i < n; i++) {
            int v = u;
            for (int w : adj[u]) {
                if (deg[w] < deg[v]) v = w;
            }
            if (deg[v] > 1e8) break;
            ans.push_back(v);
            u = v;
            for (int w : adj[u]) deg[w]--;
            deg[u] = 1e9;
        }
        if ((int)ans.size() == n) {
            bool ok = false;
            for (int v : adj[ans.back()]) if (v == ans.front()) ok = true;
            if (!ok) continue;
            solution = ans;
            return true;
        }
    }
    return false;
}

#G Tree

@020 Tree In General (LCA, HLD, Euler Tour):
struct Tree {
    vector<int> depth, parent, siz, head, begin, end;

    Tree(int n, vector<vector<int>> adj) : depth(n), parent(n), siz(n), head(n), begin(n), end(n) {
        auto dfs = [&](auto self, int u, int p) -> void {
            depth[u] = p == -1 ? 0 : depth[p] + 1;
            parent[u] = p;
            siz[u] = 1;
            for (int v : adj[u]) {
                if (v == p) continue;
                self(self, v, u);
                siz[u] += siz[v];
            }
        };
        dfs(dfs, 0, -1);
        int tim = 0;
        auto decompose = [&](auto self, int u, int h) -> void {
            head[u] = h;
            int heavy = -1;
            begin[u] = tim++;
            for (int v : adj[u]) {
                if (v == parent[u]) continue;
                if (heavy == -1 || siz[v] > siz[heavy]) heavy = v;
            }
            if (heavy != -1) self(self, heavy, h);
            for (int v : adj[u]) {
                if (v == parent[u] || v == heavy) continue;
                self(self, v, v);
            }
            end[u] = tim;
        };
        decompose(decompose, 0, 0);
    }

    int lca(int u, int v) {
        for (; head[u] != head[v]; v = parent[head[v]]) {
            if (depth[head[u]] > depth[head[v]]) swap(u, v);
        }
        if (depth[u] > depth[v]) swap(u, v);
        return u;
    }

    int getNode(int u) {
        return begin[u];
    }

    array<int, 2> getSubtree(int u) {
        return array<int, 2>{ begin[u], end[u] };
    }

    vector<array<int, 2>> getPath(int u, int v) {
        vector<array<int, 2>> res;
        for (; head[u] != head[v]; v = parent[head[v]]) {
            if (depth[head[u]] > depth[head[v]]) swap(u, v);
            res.push_back({ begin[head[v]], begin[v] + 1 });
        }
        if (depth[u] > depth[v]) swap(u, v);
        res.push_back({ begin[u], begin[v] + 1 });
        return res;
    }

    bool isProperDescendant(int upper, int lower) {
        return begin[upper] < begin[lower] && begin[lower] < end[upper];
    }

    pair<vector<int>, vector<array<int, 2>>> virtualTree(vector<int> nodes) {
        sort(nodes.begin(), nodes.end(), [&](int u, int v) { return begin[u] < begin[v]; });
        int siz = nodes.size();
        for (int i = 0; i + 1 < siz; i++) {
            nodes.push_back(lca(nodes[i], nodes[i + 1]));
        }
        sort(nodes.begin(), nodes.end(), [&](int u, int v) { return begin[u] < begin[v]; });
        nodes.resize(unique(nodes.begin(), nodes.end()) - nodes.begin());
        vector<array<int, 2>> edges;
        vector<int> stk;
        for (int u : nodes) {
            while (!stk.empty() && !isProperDescendant(stk.back(), u)) {
                stk.pop_back();
            }
            if (!stk.empty()) {
                edges.push_back({stk.back(), u});
            }
            stk.push_back(u);
        }
        return {nodes, edges};
    }
};

@020.5 Segmented Tree:

struct Tree {
    int log, idx;
    vector<int> depth;
    vector<vector<int>> lift;
    vector<vector<int>> f;
    vector<array<int, 2>> edges;

    Tree(int n, vector<vector<int>> &adj, int root = 0) : log(32 - __builtin_clz(n)), idx(0), depth(n), lift(n, vector<int>(log, -1)), f(n, vector<int>(log, -1)) {
        auto dfs = [&](auto self, int u, int p) -> void {
            for (int v : adj[u]) {
                if (v == p) continue;
                depth[v] = depth[u] + 1;
                lift[v][0] = u;
                f[v][0] = idx++;
                for (int i = 1; i < log; i++) {
                    int w = lift[v][i - 1];
                    if (w != -1) {
                        lift[v][i] = lift[w][i - 1];
                        if (f[w][i - 1] != -1) f[v][i] = idx++;
                        if (f[w][i - 1] != -1) edges.push_back({f[v][i], f[v][i - 1]});
                        if (f[w][i - 1] != -1) edges.push_back({f[v][i], f[w][i - 1]});
                    }
                }
                self(self, v, u);
            }
        };
        depth[root] = 0;
        f[root][0] = idx++;
        dfs(dfs, root, -1);
    }

    int count() {
        return idx;
    }

    vector<array<int, 2>> getEdges() {
        return edges;
    }

    int getNode(int u) {
        return f[u][0];
    }

    vector<int> getPath(int u, int v) {
        vector<int> res;
        if (depth[u] > depth[v]) swap(u, v);
        for (int i = log - 1; i >= 0; i--) {
            int w = lift[v][i];
            if (w != -1 && depth[w] >= depth[u]) {
                res.push_back(f[v][i]);
                v = w;
            }
        }
        if (u == v) {
            res.push_back(f[u][0]);
            return res;
        }
        for (int i = log - 1; i >= 0; i--) {
            if (lift[u][i] != lift[v][i]) {
                res.push_back(f[u][i]);
                res.push_back(f[v][i]);
                u = lift[u][i];
                v = lift[v][i];
            }
        }
        res.push_back(f[u][1]);
        res.push_back(f[v][0]);
        return res;
    }

    int lca(int u, int v) {
        if (depth[u] > depth[v]) swap(u, v);
        for (int i = log - 1; i >= 0; i--) {
            int w = lift[v][i];
            if (w != -1 && depth[w] >= depth[u]) v = w;
        }
        if (u == v) return u;
        for (int i = log - 1; i >= 0; i--) {
            if (lift[u][i] != lift[v][i]) {
                u = lift[u][i];
                v = lift[v][i];
            }
        }
        return lift[u][0];
    }

    int getIntermediate(int s, int t) { // not to take s == t
        int m = lca(s, t);
        if (s != m) return lift[s][0];
        for (int i = log - 1; i >= 0; i--) {
            int w = lift[t][i];
            if (w != -1 && depth[w] > depth[s]) t = w;
        }
        return t;
    }
};

@021 Small To Large (using one DS):

{
    auto add = [&](int u, int delta) {  }; // add node u to DS
    function<void(int, int, int)> addSubtree = [&](int u, int p, int delta) { // add subtree rooted at u to DS
        add(u, delta);
        for (int v : adj[u]) {
            if (v == p) continue;
            addSubtree(v, u, delta);
        }
    };

    vector<int> siz(n);
    function<void(int, int)> scout = [&](int u, int p) {
        siz[u] = 1;
        for (int v : adj[u]) {
            if (v == p) continue;
            scout(v, u);
            siz[u] += siz[v];
        }
    };
    scout(0, -1);

    function<void(int, int, bool)> compute = [&](int u, int p, bool keep) {
        int heavy = -1;
        for (int v : adj[u]) {
            if (v == p) continue;
            if (heavy == -1 || siz[v] > siz[heavy]) heavy = v;
        }
        for (int v : adj[u]) {
            if (v == p || v == heavy) continue;
            compute(v, u, false);
        }
        if (heavy != -1) compute(heavy, u, true);
        for (int v : adj[u]) {
            if (v == p || v == heavy) continue;
            addSubtree(v, u, +1);
        }
        add(u, +1);
        ans[u] = res;
        if (!keep) addSubtree(u, p, -1);
    };
    compute(0, -1, true);
    return ans;
}

@022 Centroid Tree:

struct CentroidTree {
    vector<int> parent;

    CentroidTree(int n, vector<vector<int>> adj) : parent(n) {
        vector<bool> blocked(n, false);

        vector<int> siz(n);
        function<void(int, int)> getSize = [&](int u, int p) {
            siz[u] = 1;
            for (int v : adj[u]) {
                if (v == p || blocked[v]) continue;
                getSize(v, u);
                siz[u] += siz[v];
            }
        };

        function<int(int, int, int)> getCentroid = [&](int u, int p, int n) {
            for (int v : adj[u]) {
                if (v == p || blocked[v]) continue;
                if (siz[v] > n / 2) return getCentroid(v, u, n);
            }
            return u;
        };

        function<void(int, int)> build = [&](int u, int p) {
            getSize(u, -1);
            u = getCentroid(u, -1, siz[u]);
            blocked[u] = true;
            parent[u] = p;
            for (int v : adj[u]) {
                if (blocked[v]) continue;
                build(v, u);
            }
        };
        build(0, -1);
    }
};

@023 Tree Isomorphism:

mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
{
    map<vector<long long>, long long> mp;
    auto getTreeHash = [&](int root, vector<vector<int>> adj) {
        vector<long long> f(n);
        function<void(int, int)> dfs = [&](int u, int p) {
            vector<long long> fetch;
            for (int v : adj[u]) {
                if (v == p) continue;
                dfs(v, u);
                fetch.push_back(f[v]);
            }
            sort(fetch.begin(), fetch.end());
            if (!mp.count(fetch)) mp[fetch] = rng();
            f[u] = mp[fetch];
        };
        dfs(root, -1);
        return f[root];
    };
    vector<int> cens0 = getCentroids(n, adj0);
    vector<int> cens1 = getCentroids(n, adj1);
    cen1.resize(1);
    for (int c0 : cen0) {
        for (int c1 : cen1) {
            if (getTreeHash(c0, adj0) == getTreeHash(c1, adj1)) {
                cout << "YES\n";
                return;
            }
        }
    }
    cout << "NO\n";
}

#H Math: Combinatorics, Number Theory, Numerics

@024 Combinatorics:

const int P = 1e9 + 7;

struct Combinatorics {
    int power(int a, int b) {
        int res = 1;
        for (; b; b /= 2, a = 1LL * a * a % P) {
            if (b & 1) {
                res = 1LL * res * a % P;
            }
        }
        return res;
    }

    vector<int> fac, invfac, inv;
    void compute(int n) {
        fac = vector<int>(n);
        fac[0] = 1;
        for (int i = 1; i < n; i++) {
            fac[i] = 1LL * fac[i - 1] * i % P;
        }
        invfac = vector<int>(n);
        invfac[n - 1] = power(fac[n - 1], P - 2);
        for (int i = n - 2; i >= 0; i--) {
            invfac[i] = 1LL * invfac[i + 1] * (i + 1) % P;
        }
        assert(invfac[0] == 1);
        inv = vector<int>(n);
        for (int i = 1; i < n; i++) {
            inv[i] = 1LL * fac[i - 1] * invfac[i] % P;
        }
    }

    vector<vector<int>> stirling1;
    vector<vector<int>> stirling2;
    vector<int> bell;
    void computeStirling(int n) {
        stirling1 = vector<vector<int>>(n, vector<int>(n, 0));
        stirling2 = vector<vector<int>>(n, vector<int>(n, 0));
        bell = vector<int>(n, 0);
        stirling1[0][0] = 1;
        stirling2[0][0] = 1;
        bell[0] = 1;
        for (int i = 1; i < n; i++) {
            stirling1[i][0] = 0;
            stirling2[i][0] = 0;
            for (int j = 1; j <= i; j++) {
                stirling1[i][j] = (stirling1[i - 1][j - 1] + 1LL * (i - 1) * stirling1[i - 1][j]) % P;
                stirling2[i][j] = (stirling2[i - 1][j - 1] + 1LL * j * stirling2[i - 1][j]) % P;
                bell[i] = (bell[i] + stirling2[i][j]) % P;
            }
        }
    }

    vector<int> derangement;
    void computeDerangement(int n) {
        derangement = vector<int>(n);
        derangement[0] = 1;
        derangement[1] = 0;
        for (int i = 2; i < n; i++) {
            derangement[i] = 1LL * (i - 1) * (derangement[i - 1] + derangement[i - 2]) % P;
        }
    }

    vector<vector<int>> eulerian;
    void computeEulerian(int n) {
        eulerian = vector<vector<int>>(n, vector<int>(n, 0));
        eulerian[0][0] = 1;
        for (int i = 1; i < n; i++) {
            eulerian[i][0] = 1;
            for (int j = 1; j < i; j++) {
                eulerian[i][j] = (1LL * (i - j) * eulerian[i - 1][j - 1] + 1LL * (j + 1) * eulerian[i - 1][j]) % P;
            }
        }
    }

    int Factorial(int n) {
        return fac[n];
    }

    int InvFactorial(int n) {
        return invfac[n];
    }

    int Inv(int n) {
        return inv[n];
    }

    int Binomial(int n, int k) {
        if (k < 0 || k > n) return 0;
        return 1LL * fac[n] * invfac[k] % P * invfac[n - k] % P;
    }

    int Catalan(int n) {
        return 1LL * Binomial(2 * n, n) * inv[n + 1] % P;
    }

    int Stirling1(int n, int k) {
        return stirling1[n][k];
    }

    int SignedStirling1(int n, int k) {
        int res = Stirling1(n, k);
        if ((n - k) % 2 != 0) res = (P - res) % P;
        return res;
    }

    int Stirling2(int n, int k) {
        return stirling2[n][k];
    }

    int Bell(int n) {
        return bell[n];
    }

    int Derangement(int n) { // d(n) = (n-1)(d(n-1)+d(n-2)) = n*d(n-1)+(-1)^n = round(n!/e)
        return derangement[n];
    }

    int Eulerian(int n, int k) { // e(n,k) = (n-k)*e(n-1,k-1)+(k+1)*e(n-1,k)
        return eulerian[n][k];
    }
};

@025 Number Theory:

~Prime link and Phi

vector<int> link;
vector<int> phi;
void siege(int n) {
    link.resize(n, 0);
    phi.resize(n);
    iota(phi.begin(), phi.end(), 0);
    for (int p = 2; p < n; p++) {
        if (link[p] != 0) continue;
        for (int mp = p; mp < n; mp += p) {
            link[mp] = p;
            phi[mp] -= phi[mp] / p;
        }
    }
}

~Rho's Pollard

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

long long binpower(long long base, long long e, long long mod) {
    long long result = 1;
    base %= mod;
    while (e) {
        if (e & 1)result = (long long)result * base % mod;
        base = (long long)base * base % mod;e >>= 1;
    }
    return result;
}

bool check_composite(long long n, long long a, long long d, int s) {
    long long x = binpower(a, d, n);
    if (x == 1 or x == n - 1)return false;
    for (int r = 1; r < s; r++) {
        x = (long long)x * x % n;
        if (x == n - 1)return false;
    }
    return true;
}

bool MillerRabin_checkprime(long long n) {
    if (n < 2)return false;
    int r = 0;
    long long d = n - 1;
    while ((d & 1) == 0) {
        d >>= 1;
        r++;
    }
    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
        if (n == a)return true;
        if (check_composite(n, a, d, r))return false;
    }
    return true;
}

int mult(int a, int b, int mod) {
    return (long long)a * b % mod;
}

int F(int x, int c, int mod) {
    return (mult(x, x, mod) + c) % mod;
}

int rho(int n, int x0=2, int c=1) {
    int x = x0;
    int y = x0;
    int g = 1;
    if (n % 2 == 0) return 2;
    while (g == 1) {
        x = F(x, c, n);
        y = F(y, c, n);
        y = F(y, c, n);
        g = __gcd(abs(x - y), n);
    }
    return g;
}

vector<int> Rho_factorization(int n) {
    vector<int> b;
    vector<int> s;
    if (n == 1) { return b; }
    while (!MillerRabin_checkprime(n)){
        long long k;
        while (1){
            int p = (rng()%(n-2))+2, q = (rng()%(n-1))+1;
            k = rho(n,p,q);
            if (MillerRabin_checkprime(k)) break;
        }
        s.push_back(k);
        n/=k;
    }
    s.push_back(n);
    for (int i : s) b.push_back(i);
    return b;
}

@026 FFT:

using cd = complex<double>;
const double PI = acos(-1);

void fft(vector<cd> & a, bool invert) {
    int n = a.size();
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
        if (i < j)
            swap(a[i], a[j]);
    }
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
    if (invert) {
        for (cd & x : a)
            x /= n;
    }
}

vector<long long> multiply(vector<long long> const& a, vector<long long> const& b) {
    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < a.size() + b.size())
        n <<= 1;
    fa.resize(n);
    fb.resize(n);
    fft(fa, false);
    fft(fb, false);
    for (int i = 0; i < n; i++)
        fa[i] *= fb[i];
    fft(fa, true);
    vector<long long> result(n);
    for (int i = 0; i < n; i++)
        result[i] = round(fa[i].real());
    return result;
}

int main() {
    vector<long long> a = {2, 1, 3};
    vector<long long> b = {3, 1};
    vector<long long> c = multiply(a, b);
    for (int x : c) {
        cout << x << ' ';
    }
}

@026.5 Gaussian Elimination: this one is for finite field, to make it real number, replace Z with double, and replace the Z.inv()

using i64 = long long;
template<class T>
constexpr T power(T a, i64 b) {
    T res {1};
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}

template<i64 P>
struct MInt {
    i64 x;
    constexpr MInt() : x {0} {}
    constexpr MInt(i64 x) : x {norm(x % getMod())} {}

    static i64 Mod;
    constexpr static i64 getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(i64 Mod_) {
        Mod = Mod_;
    }
    constexpr i64 norm(i64 x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr i64 val() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        if (getMod() < (1ULL << 31)) {
            x = x * rhs.x % int(getMod());
        } else {
            x = mul(x, rhs.x, getMod());
        }
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
    friend constexpr bool operator<(MInt lhs, MInt rhs) {
        return lhs.val() < rhs.val();
    }
};

template<>
i64 MInt<0>::Mod = 1000000007;

constexpr int P = 1000000007;
using Z = MInt<P>;

int solveLinear(vector<vector<Z>> &A, vector<Z> &b, vector<Z> &x) {
    int n = A.size(), m = x.size(), rank = 0;
    if (n > 0) assert(A[0].size() == m);

    vector<int> order(m);
    iota(order.begin(), order.end(), 0);

    for (int i = 0; i < n; i++) {
        Z bv = Z(0);
        int br, bc;
        for (int r = i; r < n; r++) {
            for (int c = i; c < m; c++) {
                if (A[r][c] != Z(0)) {
                    bv = A[r][c];
                    br = r;
                    bc = c;
                }
            }
        }
        if (bv == Z(0)) {
            for (int r = i; r < n; r++) {
                if (b[r] != Z(0)) return -1;
            }
            break;
        }
        swap(A[i], A[br]);
        swap(b[i], b[br]);
        swap(order[i], order[bc]);
        for (int r = 0; r < n; r++) {
            swap(A[r][i], A[r][bc]);
        }
        Z coef0 = A[i][i].inv();
        for (int r = i + 1; r < n; r++) {
            Z coef = coef0 * A[r][i];
            for (int c = i; c < m; c++) {
                A[r][c] -= coef * A[i][c];
            }
            b[r] -= coef * b[i];
        }
        rank++;
    }

    fill(x.begin(), x.end(), 0);
    for (int i = rank - 1; i >= 0; i--) {
        b[i] /= A[i][i];
        x[order[i]] = b[i];
        for (int r = 0; r < i; r++) {
            b[r] -= b[i] * A[r][i];
        }
    }

    return rank;
}

@027 Chinese Remainder Theorem (CRT): merge (x = a0 (mod n0)) and (x = a1 (mod n1)) into (x = A (mod N)), returns by (A, N) or (-1, -1) if no solution. Also solves diophantine

long long gcd(long long a, long long b, long long &x, long long &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    long long _x, _y;
    long long g = gcd(b, a % b, _x, _y);
    x = _y;
    y = _x - _y * (a / b);
    return g;
}

array<long long, 2> crt(array<long long, 2> eq0, array<long long, 2> eq1) {
    auto [a0, n0] = eq0;
    auto [a1, n1] = eq1;
    long long x0, x1;
    long long g = gcd(n0, -n1, x0, x1);
    if ((a0 - a1) % g != 0) return array<long long, 2>{-1, -1};
    x0 *= -(a0 - a1) / g;
    x1 *= -(a0 - a1) / g;
    long long n = n0 / __gcd(n0, n1) * n1;
    long long a = n0 * (x0 % (n1 / g)) % n + a0;
    a = (a % n + n) % n;
    return array<long long, 2>{a, n};
}

@028 Fibonacci (by doubling):

long long recurFibo(long long n) {
    map<long long, int> memorize;
    function<int(long long)> compute = [&](long long n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        if (n == 2) return 1;
        if (n == 3) return 2;
        if (memorize.count(n)) return memorize[n];
        int &res = memorize[n];
        long long n1 = n / 2;
        long long n2 = n - n1;
        res = (1LL * compute(n1 - 1) * compute(n2) + 1LL * compute(n1) * compute(n2 + 1)) % P;
        return res;
    };
    return compute(n);
}

@029 Math's note:

~ Lucas's Theorem:
    Binomial(n, k) = product(Binomial(ni,ki)) (mod b)
    where ni and ki are digits in base prime b.
    And so Binomial(n, k) = 1 (mod 2) if and only if k is submask of n

~ Number of tree:
    on n vertices: n^(n-2)
    on k existing trees of size ni: n1*n2*nk*n^(k-2)
    with degrees di: (n-2)! / (d1-1)! / (di-1)! / (dn-1)!

#I Geometry

@030 General Geometry:

typedef complex<long long> point;
long long cross(point a, point b) {
    return (conj(a) * b).imag();
}
long long dot(point a, point b) {
    return (conj(a) * b).real();
}

int sgn(long long x) {
    if (x == 0) return 0;
    return x > 0 ? +1 : -1;
}

bool colinear(point a, point b, point c) {
    return cross(a - b, a - c) == 0;
}

bool between(point x, point a, point b) {
    if (!colinear(a, b, x)) return false;
    return dot(a - x, b - x) <= 0;
}

bool intersect(point a0, point a1, point b0, point b1) { // positive respond on intersection among endpoints
    if (colinear(a0, a1, b0) && colinear(a0, a1, b1)) {
        return between(a0, b0, b1) || between(a1, b0, b1) || between(b0, a0, a1) || between(b1, a0, a1);
    } else {
        bool proxy0 = sgn(cross(a1 - a0, b0 - a0)) * sgn(cross(a1 - a0, b1 - a0)) <= 0;
        bool proxy1 = sgn(cross(b1 - b0, a0 - b0)) * sgn(cross(b1 - b0, a1 - b0)) <= 0;
        return proxy0 && proxy1;
    }
}

bool inside(point p, vector<point> &a) { // assumes a to be ordered in clockwise order, strictly inside
    int l = 1, r = a.size() - 1;
    if (cross(a[l] - a[0], p - a[0]) >= 0) return false;
    if (cross(a[r] - a[0], p - a[0]) <= 0) return false;
    while (l + 1 < r) {
        int m = (l + r) >> 1;
        if (cross(a[m] - a[0], p - a[0]) <= 0) {
            l = m;
        } else {
            r = m;
        }
    }
    if (cross(a[r] - a[l], p - a[l]) >= 0) return false;
    return true;
}

@031 Minkowski Sum:

typedef complex<long long> point;
typedef vector<point> polygon;
long long cross(point a, point b) {
    return (conj(a) * b).imag();
}

void anchor(polygon &a) {
    int anc = 0;
    for (int i = 0; i < (int)a.size(); i++) {
        if (a[i].real() < a[anc].real()) anc = i;
        else if (a[i].real() == a[anc].real() && a[i].imag() < a[anc].imag()) anc = i;
    }
    rotate(a.begin(), a.begin() + anc, a.end());
}

polygon operator+(polygon a, polygon b) { // assumes polygons are strictly convex and in counter-clockwise order
    anchor(a);
    anchor(b);
    int n = a.size();
    int m = b.size();
    polygon res = { a[0] + b[0] };
    int i = 0, j = 0;
    while (i < n && j < m) {
        long long cr = cross(a[(i + 1) % n] - a[i], b[(j + 1) % m] - b[j]);
        if (cr == 0) {
            i++;
            j++;
        }
        if (cr > 0) {
            i++;
        }
        if (cr < 0) {
            j++;
        }
        res.push_back(a[i % n] + b[j % m]);
    }
    while (i < n) {
        i++;
        res.push_back(a[i % n] + b[j % m]);
    }
    while (j < m) {
        j++;
        res.push_back(a[i % n] + b[j % m]);
    }
    res.pop_back();
    return res;
}

@032 Nearest points:

const long long INF = 9e18;

long long dist(array<int, 2> a, array<int, 2> b) {
    return 1LL * (a[0] - b[0]) * (a[0] - b[0]) + 1LL * (a[1] - b[1]) * (a[1] - b[1]);
}

int main() {
    vector<array<int, 2>> a(n);

    sort(a.begin(), a.end(), [&](array<int, 2> x, array<int, 2> y) { return x[0] < y[0]; });
    long long d = INF;

    function<void(int, int)> dnc = [&](int l, int r) {
        if (l + 1 == r) return;
        int m = (l + r) >> 1;
        int mx = a[m][0];
        dnc(l, m);
        dnc(m, r);
        vector<array<int, 2>> temp(r - l);
        merge(a.begin() + l, a.begin() + m, a.begin() + m, a.begin() + r, temp.begin(), [&](array<int, 2> x, array<int, 2> y) { return x[1] < y[1]; });
        copy(temp.begin(), temp.end(), a.begin() + l);
        vector<array<int, 2>> fetch;
        for (int i = l; i < r; i++) {
            if (1LL * (a[i][0] - mx) * (a[i][0] - mx) < d) {
                fetch.push_back(a[i]);
            }
        }
        for (int i = 0; i < fetch.size(); i++) {
            for (int j = i - 1; j >= 0; j--) {
                if (1LL * (fetch[i][1] - fetch[j][1]) * (fetch[i][1] - fetch[j][1]) >= d) break;
                d = min(d, dist(fetch[i], fetch[j]));
            }
        }
    };
    dnc(0, n);

    cout << d << '\n';
}

@033 Convex Hull Construction:

typedef complex<long long> point;
long long cross(point a, point b) {
    return (conj(a) * b).imag();
}

vector<point> getConvexHull(vector<point> a) { // colinear included, returned in clockwise order
    sort(a.begin(), a.end(), [&](point x, point y) {
        if (x.real() == y.real()) return x.imag() < y.imag();
        return x.real() < y.real();
    });
    vector<point> lower_hull;
    for (point p : a) {
        while (lower_hull.size() >= 2 && cross(lower_hull[lower_hull.size() - 1] - p, lower_hull[lower_hull.size() - 2] - p) > 0) { // change to >= to not include colinear points
            lower_hull.pop_back();
        }
        lower_hull.push_back(p);
    }
    vector<point> upper_hull;
    reverse(a.begin(), a.end());
    for (point p : a) {
        while (upper_hull.size() >= 2 && cross(upper_hull[upper_hull.size() - 1] - p, upper_hull[upper_hull.size() - 2] - p) > 0) { // change to >= to not include colinear points
            upper_hull.pop_back();
        }
        upper_hull.push_back(p);
    }
    lower_hull.pop_back();
    upper_hull.pop_back();
    vector<point> hull;
    hull.insert(hull.end(), lower_hull.begin(), lower_hull.end());
    hull.insert(hull.end(), upper_hull.begin(), upper_hull.end());
    return hull;
}

@034 Rectangle Union Area: either with implitcit or with compressing

~ Through implicit

const int INF = (int)1e9 + 12345;

struct RectUnionArea {
    struct Node {
        int sum = 0, paint = 0;
        int ln = -1, rn = -1;
    };
    int CL, CR;
    vector<Node> nodes;

    RectUnionArea() : CL(INF), CR(-INF), nodes(1) {}

    void add(int ql, int qr, int delta, int &idx, int l, int r) {
        if (r <= ql || qr <= l) {
            return;
        }
        if (idx == -1) {
            idx = nodes.size();
            nodes.push_back(Node());
        }
        if (ql <= l && r <= qr) {
            nodes[idx].paint += delta;
            nodes[idx].sum = nodes[idx].paint > 0 ? r - l : (nodes[idx].ln == -1 ? 0 : nodes[nodes[idx].ln].sum) + (nodes[idx].rn == -1 ? 0 : nodes[nodes[idx].rn].sum);
            return;
        }
        int m = (l + r) >> 1;
        Node goat = nodes[idx];
        add(ql, qr, delta, goat.ln, l, m);
        add(ql, qr, delta, goat.rn, m, r);
        nodes[idx] = goat;
        nodes[idx].sum = nodes[idx].paint > 0 ? r - l : (nodes[idx].ln == -1 ? 0 : nodes[nodes[idx].ln].sum) + (nodes[idx].rn == -1 ? 0 : nodes[nodes[idx].rn].sum);
    }

    void add(int ql, int qr, int delta) { int goat = 0; add(ql, qr, delta, goat, CL, CR); }
    int sum() { return nodes[0].sum; }

    vector<array<int, 4>> events;
    void addRect(int x0, int y0, int x1, int y1) {
        events.push_back({x0, y0, y1, +1});
        events.push_back({x1, y0, y1, -1});
        CL = min(CL, y0);
        CR = max(CR, y1);
    }

    long long getArea() {
        sort(events.begin(), events.end());
        int last = events.front()[0];
        long long res = 0;
        for (array<int, 4> e : events) {
            int x = e[0], y0 = e[1], y1 = e[2], delta = e[3];
            res += 1LL * (x - last) * sum();
            add(y0, y1, delta);
            last = x;
        }
        return res;
    }
};

~ Through compressing

struct RectUnionArea {
    vector<int> val;
    vector<array<int, 4>> events;

    struct Node {
        int mn, cnt, lazy;
        Node operator+(Node b) {
            Node a = *this;
            if (a.mn > b.mn) swap(a, b);
            Node res = a;
            if (a.mn == b.mn) res.cnt += b.cnt;
            res.lazy = 0;
            return res;
        }
    };
    vector<Node> nodes;

    void build(int idx, int l, int r) {
        nodes[idx] = { 0, val[r] - val[l], 0 };
        if (l + 1 < r) {
            int m = (l + r) >> 1;
            build(2 * idx + 1, l, m);
            build(2 * idx + 2, m, r);
        }
    }

    void apply(int idx, int l, int r, int delta) {
        nodes[idx].mn += delta;
        nodes[idx].lazy += delta;
    }

    void down(int idx, int l, int r) {
        int m = (l + r) >> 1;
        apply(2 * idx + 1, l, m, nodes[idx].lazy);
        apply(2 * idx + 2, m, r, nodes[idx].lazy);
        nodes[idx].lazy = 0;
    }

    void add(int ql, int qr, int delta, int idx, int l, int r) {
        if (r <= ql || qr <= l) return;
        if (ql <= l && r <= qr) {
            apply(idx, l, r, delta);
            return;
        }
        down(idx, l, r);
        int m = (l + r) >> 1;
        add(ql, qr, delta, 2 * idx + 1, l, m);
        add(ql, qr, delta, 2 * idx + 2, m, r);
        nodes[idx] = nodes[2 * idx + 1] + nodes[2 * idx + 2];
    }

    int getGlobalNonZero() {
        return val.back() - val.front() - (nodes[0].mn == 0) * nodes[0].cnt;
    }

    void addRect(int x0, int y0, int x1, int y1) {
        if (x0 > x1) swap(x0, x1);
        if (y0 > y1) swap(y0, y1);
        events.push_back({ x0, +1, y0, y1 });
        events.push_back({ x1, -1, y0, y1 });
        val.push_back(y0);
        val.push_back(y1);
    }

    long long getUnionArea() {
        if (events.empty()) return 0LL;
        sort(events.begin(), events.end());

        sort(val.begin(), val.end());
        val.resize(unique(val.begin(), val.end()) - val.begin());
        int C = val.size() - 1;

        nodes = vector<Node>(4 * C);
        build(0, 0, C);

        int last = events[0][0];
        long long res = 0;

        for (auto [x, delta, y0, y1] : events) {
            y0 = lower_bound(val.begin(), val.end(), y0) - val.begin();
            y1 = lower_bound(val.begin(), val.end(), y1) - val.begin();
            res += 1LL * (x - last) * getGlobalNonZero();
            add(y0, y1, delta, 0, 0, C);
            last = x;
        }

        return res;
    }
};

#J Strings

@035 Hash:

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int X0 = vector<int>{29, 31, 37, 41}[rng() % 4];

struct Hash {
    const int X = X0;
    const int P = (int)1e9 + 7;

    string s;
    int n;
    vector<long long> hsh1, hsh2;
    vector<long long> power1, power2;

    Hash(string s) : s(s), n(s.length()), hsh1(n + 1), hsh2(n + 1), power1(n + 1), power2(n + 1) {
        hsh1[0] = hsh2[0] = 0;
        power1[0] = power2[0] = 1;
        for (int i = 0; i < n; i++) {
            int c = s[i] - 'a' + 1;
            hsh1[i + 1] = (hsh1[i] * X + c) % P;
            hsh2[i + 1] = hsh2[i] * X + c;
            power1[i + 1] = power1[i] * X % P;
            power2[i + 1] = power2[i] * X;
        }
    }

    void push_back(char ch) {
        int c = ch - 'a' + 1;
        s.push_back(ch);
        n++;
        hsh1.push_back((hsh1.back() * X + c) % P);
        hsh2.push_back(hsh2.back() * X + c);
        power1.push_back(power1.back() * X % P);
        power2.push_back(power2.back() * X);
    }

    void pop_back() {
        s.pop_back();
        n--;
        hsh1.pop_back();
        hsh2.pop_back();
        power1.pop_back();
        power2.pop_back();
    }

    array<long long, 2> get(int l, int r) {
        long long h1 = (hsh1[r] - hsh1[l] * power1[r - l] % P + P) % P;
        long long h2 = hsh2[r] - hsh2[l] * power2[r - l];
        return array<long long, 2>{h1, h2};
    }

    array<long long, 2> get() {
        return array<long long, 2>{hsh1[n], hsh2[n]};
    }
};

@036 Z, Pi, Manacher's:

vector<int> getZ(string s) {
    int n = s.size();
    vector<int> z(n);
    z[0] = 0;
    for (int i = 1, l = 0, r = 0; i < n; i++) {
        if (i < r) {
            z[i] = min(r - i, z[i - l]);
        }
        while (i + z[i] < n && s[i + z[i]] == s[z[i]]) {
            z[i]++;
        }
        if (i + z[i] > r) {
            r = i + z[i];
            l = i;
        }
    }
    return z;
}

vector<int> getPi(string s) {
    int n = s.size();
    vector<int> pi(n);
    pi[0] = 0;
    for (int i = 1; i < n; i++) {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j]) {
            j = pi[j - 1];
        }
        pi[i] = j + (s[i] == s[j]);
    }
    return pi;
}

vector<int> getManacher(string _s) { // return 2n-1 numbers, the i-th of these is the length of the longest palindrome centered at that position, or 0 if doesn't exist
    string s = "$";
    for (char c : _s) {
        s += c;
        s += '#';
    }
    s.pop_back();
    s += '&';
    int n = s.length();
    vector<int> z(n, 1);
    for (int i = 1, l = 0, r = 0; i < n - 1; i++) {
        if (i < r) {
            z[i] = min(r - i, z[l + r - i - 1]);
        }
        while (s[i - z[i]] == s[i + z[i]]) {
            z[i]++;
        }

        if (i + z[i] > r) {
            r = i + z[i];
            l = i - z[i] + 1;
        }

        if (i & 1) {
            z[i] = (z[i] - 1) / 2 * 2 + 1;
        } else {
            z[i] = z[i] / 2 * 2;
        }
    }
    return vector<int>(z.begin() + 1, z.end() - 1);
}

@037 Aho Corasick (also log containers trick):

struct AhoCorasick {
    struct Node {
        int p;
        int c;
        int cnt = 0;
        array<int, 2> next = array<int, 2>{0, 0};
        int link = 0;
        array<int, 2> go = array<int, 2>{0, 0};
        Node(int p = -1, int c = -1) : p(p), c(c) {}
    };

    vector<Node> trie;

    AhoCorasick() : trie(1) {}

    void add(vector<int> s) {
        int u = 0;
        for (int c : s) {
            if (!trie[u].next[c]) {
                trie[u].next[c] = trie.size();
                trie.emplace_back(u, c);
            }
            u = trie[u].next[c];
        }
        trie[u].cnt++;
    }

    void add(vector<vector<int>> ss) {
        for (vector<int> s : ss) {
            add(s);
        }
    }

    vector<int> q;
    void build() {
        int n = trie.size();
        q.resize(n);
        int cur = 0;
        q[cur++] = 0;
        for (int i = 0; i < n; i++) {
            int u = q[i];
            trie[u].link = u == 0 || trie[u].p == 0 ? 0 : trie[trie[trie[u].p].link].go[trie[u].c];
            trie[u].cnt += trie[trie[u].link].cnt;
            for (int c = 0; c < 2; c++) {
                trie[u].go[c] = trie[u].next[c] ? trie[u].next[c] : u == 0 ? 0 : trie[trie[u].link].go[c];
                if (trie[u].next[c]) {
                    q[cur++] = trie[u].next[c];
                }
            }
        }
    }

    int size() { return trie.size(); }
    int link(int u) { return trie[u].link; }
    int go(int u, int c) { return trie[u].go[c]; }
    int cnt(int u) { return trie[u].cnt; }
};

struct AhoCorasickContainer {
    vector<vector<vector<int>>> sss;
    vector<AhoCorasick> ahos;
    int status;
    AhoCorasickContainer(int LOG) : sss(LOG), ahos(LOG), status(0) {}

    void add(vector<vector<int>> ss, int i) {
        if (status >> i & 1) {
            ss.insert(ss.end(), sss[i].begin(), sss[i].end());
            sss[i].clear();
            ahos[i] = AhoCorasick();
            status ^= 1 << i;
            add(ss, i + 1);
        } else {
            ahos[i].add(ss);
            ahos[i].build();
            sss[i] = ss;
            status ^= 1 << i;
        }
    }

    void add(vector<int> s) {
        add({s}, 0);
    }
};

@038 Suffix Automaton: the poorest one, add more yourself, sorry

const int C = 26;
struct SuffixAutomaton {
    struct Node {
        int len, link;
        vector<int> next;
        Node() : len(0), link(-1), next(C, 0) {}
    };

    vector<Node> nodes;
    int cur;

    SuffixAutomaton() : nodes(1), cur(0) {}

    int add(int c) {
        int prev = cur;
        cur = nodes.size();
        nodes.emplace_back();
        nodes[cur].len = nodes[prev].len + 1;
        int p = prev;
        while (p != -1 && !nodes[p].next[c]) {
            nodes[p].next[c] = cur;
            p = nodes[p].link;
        }
        if (p == -1) {
            nodes[cur].link = 0;
        } else {
            int q = nodes[p].next[c];
            if (nodes[p].len + 1 == nodes[q].len) {
                nodes[cur].link = q;
            } else {
                int clone = nodes.size();
                nodes.push_back(nodes[q]);
                nodes[clone].len = nodes[p].len + 1;
                nodes[cur].link = nodes[q].link = clone;
                while (p != -1 && nodes[p].next[c] == q) {
                    nodes[p].next[c] = clone;
                    p = nodes[p].link;
                }
            }
        }
        return cur;
    }

    int size() { return nodes.size(); }
    int link(int u) { return nodes[u].link; }
    int next(int u, int c) { return nodes[u].next[c]; }
};

@039 Palindrome Tree:

struct PalinTree {
    struct Node {
        int len;
        map<char, int> adj;
        int link;
        int val; // number of endpos's of this palindrome
    };

    string s;
    int cur;
    vector<Node> pt;

    PalinTree(string s) : s(s), pt(2) {
        pt[0].len = -1;
        pt[0].link = 0;
        pt[0].val = 0;
        pt[1].len = 0;
        pt[1].link = 0;
        pt[1].val = 0;
        cur = 0;
    }

    void add(int i) {
        while (true) {
            if (i - 1 - pt[cur].len >= 0 && s[i - 1 - pt[cur].len] == s[i]) {
                break;
            }
            cur = pt[cur].link;
        }

        if (pt[cur].adj.count(s[i])) {
            cur = pt[cur].adj[s[i]];
            return;
        }

        int link = cur;
        cur = (int)pt.size();
        pt.push_back({});
        pt[cur].len = pt[link].len + 2;
        pt[link].adj[s[i]] = cur;

        if (pt[cur].len == 1) {
            pt[cur].link = 1;
            pt[cur].val = 1;
            return;
        }

        while (true) {
            link = pt[link].link;
            if (i - 1 - pt[link].len >= 0 && s[i - 1 - pt[link].len] == s[i]) {
                pt[cur].link = pt[link].adj[s[i]];
                pt[cur].val = pt[pt[cur].link].val + 1;
                return;
            }
        }

        assert(0);
    }
};

#K Mo's

@040 Standard Mo's

{
    int cl = 0, cr = 0;
    auto getAnswer = [&](int l, int r) {
        while (cl > l) add(--cl);
        while (cr < r) add(cr++);
        while (r < cr) remove(--cr);
        while (cl < l) remove(cl++);
        return fetchResult();
    };
}

@041 Online Mo's

int main() {
    vector<array<int, 3>> qs; // only queries: l, r, time of query
    vector<array<int, 4>> changes; // { time of change, object to change, before change, after change }

    changes.push_back({ -1, -1, 0, 0 });
    changes.push_back({ q, -1, 0, 0 });

    const int B = 2700;
    sort(qs.begin(), qs.end(), [&](array<int, 3> e0, array<int, 3> e1) {
        int l0 = e0[0] / B, l1 = e1[0] / B;
        if (l0 != l1) return l0 < l1;
        int r0 = e0[1] / B, r1 = e1[1] / B;
        if (r0 != r1) return (l0 & 1) ? r0 > r1 : r0 < r1;
        return (r0 & 1) ? e0[2] > e1[2] : e0[2] < e1[2];
    });

    auto add = [&](int x) { };
    auto remove = [&](int x) { };
    auto change = [&](int p, int x) {
        if (cl <= p && p < cr) {
            remove(a[p]);
            add(x);
        }
        a[p] = x; // apply change
    };

    auto fix = [&](int l, int r, int i) {
        while (l < cl) add(a[--cl]);
        while (cr < r) add(a[cr++]);
        while (cl < l) remove(a[cl++]);
        while (r < cr) remove(a[--cr]);
        while (changes[cii][0] < i) { change(changes[cii][1], changes[cii][3]), cii++; }
        while (i < changes[cii - 1][0]) { cii--; change(changes[cii][1], changes[cii][2]); }
    };

    auto getMex = [&]() { // query
        int mex = 0;
        while (freq_cnt[mex]) mex++;
        return mex;
    };

    vector<int> ans(q, -1);
    for (auto [l, r, i] : qs) {
        fix(l, r, i);
        ans[i] = getMex();
    }
}

@042 Mo's on Tree

struct Tree {
    vector<int> depth, parent, siz, head, begin, end;

    Tree(int n, vector<vector<int>> &adj) : depth(n), parent(n), siz(n), head(n), begin(n), end(n) {
        function<void(int, int)> dfs = [&](int u, int p) {
            depth[u] = p == -1 ? 0 : depth[p] + 1;
            parent[u] = p;
            siz[u] = 1;
            for (int v : adj[u]) {
                if (v == p) continue;
                dfs(v, u);
                siz[u] += siz[v];
            }
        };
        dfs(0, -1);
        int tim = 0;
        function<void(int, int)> decompose = [&](int u, int h) {
            head[u] = h;
            begin[u] = tim++;
            int heavy = -1;
            for (int v : adj[u]) {
                if (v == parent[u]) continue;
                if (heavy == -1 || siz[v] > siz[heavy]) heavy = v;
            }
            if (heavy != -1) decompose(heavy, h);
            for (int v : adj[u]) {
                if (v == parent[u] || v == heavy) continue;
                decompose(v, v);
            }
            end[u] = tim++;
        };
        decompose(0, 0);
    }

    int lca(int u, int v) {
        for (; head[u] != head[v]; v = parent[head[v]]) {
            if (depth[head[u]] > depth[head[v]]) swap(u, v);
        }
        if (depth[u] > depth[v]) swap(u, v);
        return u;
    }
};

int main() {
    vector<vector<int>> adj(n);
    Tree tree(n, adj);

    vector<int> mp(n + n); // map position on 2n euler's tour to node
    for (int u = 0; u < n; u++) {
        mp[tree.begin[u]] = mp[tree.end[u]] = u;
    }

    vector<array<int, 2>> qs(q);
    vector<array<int, 3>> order(q);
    for (int i = 0; i < q; i++) {
        int u, v;
        cin >> u >> v;
        u--;
        v--;
        // get (l, r) from (u, v)
        int uv = tree.lca(u, v);
        qs[i] = { u, v };
        if (uv == u || uv == v) {
            if (v == uv) swap(u, v);
            int l = tree.begin[u];
            int r = tree.begin[v] + 1;
            order[i] = { l, r, i };
        } else {
            if (tree.begin[u] > tree.begin[v]) swap(u, v);
            int l = tree.end[u];
            int r = tree.begin[v] + 1;
            order[i] = { l, r, i };
        }
    }

    const int B = 252;
    sort(order.begin(), order.end(), [&](array<int, 3> e0, array<int, 3> e1) {
        int l0 = e0[0] / B, l1 = e1[0] / B;
        if (l0 != l1) return l0 < l1;
        return (l0 & 1) ? e0[1] > e1[1] : e0[1] < e1[1];
    });

    int cl = 0, cr = 0;
    vector<int> present(n, 0);
    vector<int> cnt(C, 0);
    int res = 0;

    auto toggle = [&](int u) {
        present[u] ^= 1;
        if (present[u]) {
            cnt[a[u]]++;
            res += cnt[a[u]] == 1;
        } else {
            cnt[a[u]]--;
            res -= cnt[a[u]] == 0;
        }
    };

    auto fix = [&](int l, int r) {
        while (l < cl) toggle(mp[--cl]);
        while (cr < r) toggle(mp[cr++]);
        while (cl < l) toggle(mp[cl++]);
        while (r < cr) toggle(mp[--cr]);
    };

    auto query = [&](int u, int v) {
        int uv = tree.lca(u, v);
        if (uv == u || uv == v) {
            return res;
        } else {
            toggle(uv);
            int fetch = res;
            toggle(uv);
            return fetch;
        }
    };
}

#L Data Structures

@043 Fenwick:

template <class T>
struct Fenwick {
    int n, log;
    vector<T> bit;

    Fenwick(int n) : n(n), log(32 - __builtin_clz(n + 1)), bit(n + 1, 0) {}

    void add(int i, T delta) {
        for (i++; i <= n; i += i & -i) {
            bit[i] += delta;
        }
    }

    T sum(int i) {
        T res = 0;
        for (; i > 0; i -= i & -i) {
            res += bit[i];
        }
        return res;
    }

    int kth(T k) {
        T sum = 0;
        int pos = 0;
        for (int l = log - 1; l >= 0; l--) {
            if (pos + (1 << l) <= n && sum + bit[pos + (1 << l)] <= k) {
                pos += 1 << l;
                sum += bit[pos];
            }
        }
        return pos;
    }
};

@044 Lazy Propagation: this is for range assignment, range increment and range summation

struct SegmentTree {
    int n;
    vector<long long> sum;
    vector<long long> lazy;
    vector<int> force;

    SegmentTree(int n) : n(n), sum(4 * n, 0), lazy(4 * n, 0), force(4 * n, -1) {}

    void apply(int idx, int l, int r, int val, long long delta) {
        if (val != -1) {
            sum[idx] = 1LL * val * (r - l);
            lazy[idx] = 0;
            force[idx] = val;
        }
        sum[idx] += 1LL * delta * (r - l);
        lazy[idx] += delta;
    }

    void down(int idx, int l, int r) {
        int m = (l + r) >> 1;
        apply(2 * idx + 1, l, m, force[idx], lazy[idx]);
        apply(2 * idx + 2, m, r, force[idx], lazy[idx]);
        force[idx] = -1;
        lazy[idx] = 0;
    }

    void add(int ql, int qr, int val, int delta, int idx, int l, int r) {
        if (r <= ql || qr <= l) return;
        if (ql <= l && r <= qr) return apply(idx, l, r, val, delta);
        down(idx, l, r);
        int m = (l + r) >> 1;
        add(ql, qr, val, delta, 2 * idx + 1, l, m);
        add(ql, qr, val, delta, 2 * idx + 2, m, r);
        sum[idx] = sum[2 * idx + 1] + sum[2 * idx + 2];
    }

    long long getSum(int ql, int qr, int idx, int l, int r) {
        if (r <= ql || qr <= l) return 0LL;
        if (ql <= l && r <= qr) return sum[idx];
        down(idx, l, r);
        int m = (l + r) >> 1;
        return getSum(ql, qr, 2 * idx + 1, l, m) + getSum(ql, qr, 2 * idx + 2, m, r);
    }

    void add(int ql, int qr, int val, int delta) { add(ql, qr, val, delta, 0, 0, n); }
    long long getSum(int ql, int qr) { return getSum(ql, qr, 0, 0, n); }
};

@045 Implicit with Lazy: add an arithmetic progression to a range, range summation

struct SegmentTree {
    struct Node {
        long long sum = 0;
        long long a = 0, b = 0;
        int ln = 0, rn = 0;
    };

    int C;
    vector<Node> nodes;

    SegmentTree(int C) : C(C), nodes(2) {}

    void apply(int &idx, int l, int r, long long a, long b) {
        if (idx == 0) {
            idx = nodes.size();
            nodes.emplace_back();
        }
        nodes[idx].sum += a * (r - l) + b * (r - l) * (r - l - 1) / 2;
        nodes[idx].a += a;
        nodes[idx].b += b;
    }

    void down(int &idx, int l, int r) {
        if (idx != 0) {
            int m = (l + r) >> 1;
            Node goat = nodes[idx];
            apply(goat.ln, l, m, nodes[idx].a, nodes[idx].b);
            apply(goat.rn, m, r, nodes[idx].b * (m - l) + nodes[idx].a, nodes[idx].b);
            goat.a = 0;
            goat.b = 0;
            nodes[idx] = goat;
        } else {
            idx = nodes.size();
            nodes.emplace_back();
        }
    }

    void add(int ql, int qr, long long a, long long b, int &idx, int l, int r) {
        if (r <= ql || qr <= l) return;
        if (ql <= l && r <= qr) return apply(idx, l, r, b * (l - ql) + a, b);
        down(idx, l, r);
        int m = (l + r) >> 1;
        Node goat = nodes[idx];
        add(ql, qr, a, b, goat.ln, l, m);
        add(ql, qr, a, b, goat.rn, m, r);
        goat.sum = nodes[goat.ln].sum + nodes[goat.rn].sum;
        nodes[idx] = goat;
    }

    long long getSum(int ql, int qr, int idx, int l, int r) {
        if (r <= ql || qr <= l) return 0LL;
        if (ql <= l && r <= qr) return nodes[idx].sum;
        down(idx, l, r);
        int m = (l + r) >> 1;
        return getSum(ql, qr, nodes[idx].ln, l, m) + getSum(ql, qr, nodes[idx].rn, m, r);
    }

    void add(int ql, int qr, long long a, long long b) { int goat = 1; add(ql, qr, a, b, goat, 0, C); }
    long long getSum(int ql, int qr) { return getSum(ql, qr, 1, 0, C); }
};

@046 Fenwick 2D:

struct Fenwick2D {
    int n, m;
    vector<vector<int>> bit;
    vector<vector<int>> f;

    Fenwick2D(int n, int m) : n(n), m(m), bit(n + 1), f(n + 1) {}

    void fakeAdd(int i0, int j0) {
        for (int i = i0 + 1; i <= n; i += i & -i) {
            for (int j = j0 + 1; j <= m; j += j & -j) {
                f[i].push_back(j);
            }
        }
    }

    void work() {
        for (int i = 1; i <= n; i++) {
            f[i].push_back(0);
            sort(f[i].begin(), f[i].end());
            f[i].resize(unique(f[i].begin(), f[i].end()) - f[i].begin());
            bit[i].resize(f[i].size(), 0);
        }
    }

    void add(int i0, int j0, int x) {
        for (int i = i0 + 1; i <= n; i += i & -i) {
            for (int j = lower_bound(f[i].begin(), f[i].end(), j0 + 1) - f[i].begin(); j < (int)f[i].size(); j += j & -j) {
                bit[i][j] = max(bit[i][j], x);
            }
        }
    }

    int sum(int i0, int j0) {
        int res = 0;
        for (int i = i0; i > 0; i -= i & -i) {
            for (int j = upper_bound(f[i].begin(), f[i].end(), j0) - f[i].begin() - 1; j > 0; j -= j & -j) {
                res = max(res, bit[i][j]);
            }
        }
        return res;
    }
};

@047 Segment Tree 2D: grid n x m, default value of 0, change cell, rectangle gcd

long long gcd2(long long x, long long y) { return __gcd(x, y); }

struct SegmentTree {
    int n, m;
    vector<vector<long long>> gcd;

    SegmentTree() {}
    SegmentTree(int n, int m) : n(n), m(m), gcd(4 * n, vector<long long>(4 * m, 0)) {}

    int i, j, supidx;
    long long val;
    bool is_leaf;
    int i0, j0, i1, j1;

    void subchange(int idx, int l, int r) {
        if (l + 1 == r) {
            if (is_leaf) gcd[supidx][idx] = val;
            else gcd[supidx][idx] = gcd2(gcd[2 * supidx + 1][idx], gcd[2 * supidx + 2][idx]);
        } else {
            int m = (l + r) >> 1;
            if (j < m) subchange(2 * idx + 1, l, m);
            else subchange(2 * idx + 2, m, r);
            if (is_leaf) gcd[supidx][idx] = gcd2(gcd[supidx][2 * idx + 1], gcd[supidx][2 * idx + 2]);
            else gcd[supidx][idx] = gcd2(gcd[2 * supidx + 1][idx], gcd[2 * supidx + 2][idx]);
        }
    }
    void supchange(int idx, int l, int r) {
        if (l + 1 == r) {
            supidx = idx;
            is_leaf = true;
            subchange(0, 0, m);
        } else {
            int m = (l + r) >> 1;
            if (i < m) supchange(2 * idx + 1, l, m);
            else supchange(2 * idx + 2, m, r);
            supidx = idx;
            is_leaf = false;
            subchange(0, 0, this->m);
        }
    }
    void change(int i, int j, long long val) {
        this->i = i;
        this->j = j;
        this->val = val;
        supchange(0, 0, n);
    }

    long long subGetGcd(int idx, int l, int r) {
        if (r <= j0 || j1 <= l) return 0LL;
        if (j0 <= l && r <= j1) return gcd[supidx][idx];
        int m = (l + r) >> 1;
        return gcd2(subGetGcd(2 * idx + 1, l, m), subGetGcd(2 * idx + 2, m, r));
    }
    long long supGetGcd(int idx, int l, int r) {
        if (r <= i0 || i1 <= l) return 0LL;
        if (i0 <= l && r <= i1) { supidx = idx; return subGetGcd(0, 0, m); }
        int m = (l + r) >> 1;
        return gcd2(supGetGcd(2 * idx + 1, l, m), supGetGcd(2 * idx + 2, m, r));
    }
    long long getGcd(int i0, int j0, int i1, int j1) {
        this->i0 = i0;
        this->j0 = j0;
        this->i1 = i1;
        this->j1 = j1;
        return supGetGcd(0, 0, n);
    }
};

@048 Persistent Segment Tree: range k-th smallest

struct SegmentTree {
    struct Node {
        int sum = 0;
        int ln = 0, rn = 0;
    };

    int n;
    vector<Node> nodes;

    SegmentTree(int n) : n(n), nodes(1) {}

    void add(int i, int delta, int base, int &idx, int l, int r) {
        idx = nodes.size();
        nodes.push_back(nodes[base]);
        nodes[idx].sum += delta;
        if (l + 1 < r) {
            int m = (l + r) >> 1;
            Node goat = nodes[idx];
            if (i < m) add(i, delta, nodes[base].ln, goat.ln, l, m);
            else add(i, delta, nodes[base].rn, goat.rn, m, r);
            nodes[idx] = goat;
        }
    }

    int walk(int k, int idxl, int idxr, int l, int r) {
        if (l + 1 == r) return l;
        int m = (l + r) >> 1;
        int cntl = nodes[nodes[idxr].ln].sum - nodes[nodes[idxl].ln].sum;
        if (cntl <= k) return walk(k - cntl, nodes[idxl].rn, nodes[idxr].rn, m, r);
        else return walk(k, nodes[idxl].ln, nodes[idxr].ln, l, m);
    }

    void add(int i, int val, int base, int &idx) { add(i, val, base, idx, 0, n); }
    int walk(int x, int idxl, int idxr) { return walk(x, idxl, idxr, 0, n); }
};

@049 Sparse Table: min query

const int INF = 1e9 + 12345;

struct RMQ {
    int n, log;
    vector<vector<int>> mn;
    RMQ(vector<int> a) : n(a.size()), log(32 - __builtin_clz(n)), mn(n, vector<int>(log, INF)) {
        for (int i = n - 1; i >= 0; i--) {
            mn[i][0] = a[i];
            for (int k = 1; k < log; k++) {
                int j = i + (1 << (k - 1));
                mn[i][k] = min(mn[i][k - 1], j < n ? mn[j][k - 1] : INF);
            }
        }
    }
    int getMin(int ql, int qr) {
        int k = 31 - __builtin_clz(qr - ql);
        return min(mn[ql][k], mn[qr - (1 << k)][k]);
    }
};

@050 Rollback:

typedef array<int, 2> edge;

struct DSU {
    int n;
    vector<int> f, siz;
    vector<vector<pair<int*, int>>> stk;

    DSU(int n) : n(n), f(n), siz(n, 1) { iota(f.begin(), f.end(), 0); }

    int leader(int u) {
        while (u != f[u]) {
            u = f[u];
        }
        return u;

    }

    bool add(edge e) {
        stk.emplace_back();
        int u = e[0], v = e[1];
        u = leader(u);
        v = leader(v);
        if (u == v) return false;
        if (siz[u] < siz[v]) swap(u, v);
        stk.back().push_back({&siz[u], siz[u]});
        stk.back().push_back({&f[v], f[v]});
        stk.back().push_back({&n, n});
        siz[u] += siz[v];
        f[v] = u;
        n--;
        return true;
    }

    void rollback() {
        for (pair<int*, int> p : stk.back()) {
            *p.first = p.second;
        }
        stk.pop_back();
    }

    int count() {
        return n;
    }
};

struct SegmentTree {
    int n, T;
    vector<vector<edge>> seg;
    DSU dsu;
    vector<int> favor;

    SegmentTree(int n, int T) : n(n), T(T), seg(4 * T), dsu(n), favor(T) {}

    void add(int ql, int qr, edge e, int idx, int l, int r) {
        if (r <= ql || qr <= l) return;
        if (ql <= l && r <= qr) {
            seg[idx].push_back(e);
            return;
        }
        int m = (l + r) >> 1;
        add(ql, qr, e, 2 * idx + 1, l, m);
        add(ql, qr, e, 2 * idx + 2, m, r);
    }

    void dfs(int idx, int l, int r) {
        for (edge e : seg[idx]) {
            dsu.add(e);
        }
        if (l + 1 == r) {
            favor[l] = dsu.count();
        } else {
            int m = (l + r) >> 1;
            dfs(2 * idx + 1, l, m);
            dfs(2 * idx + 2, m, r);
        }
        for (edge e : seg[idx]) {
            dsu.rollback();
        }
    }

    void add(int ql, int qr, edge e) { add(ql, qr, e, 0, 0, T); }
    vector<int> work() { dfs(0, 0, T); return favor; }
};

int main() {
    int n, m, q;
    cin >> n >> m >> q;

    map<edge, int> mp;

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--;
        v--;
        if (u > v) swap(u, v);
        mp[{u, v}] = 0;
    }

    SegmentTree seg(n, q + 1);

    for (int t = 1; t <= q; t++) {
        int type, u, v;
        cin >> type >> u >> v;
        u--;
        v--;
        if (u > v) swap(u, v);
        if (mp.count({u, v})) {
            seg.add(mp[{u, v}], t, {u, v});
            mp.erase({u, v});
        } else {
            mp[{u, v}] = t;
        }
    }

    for (pair<edge, int> p : mp) {
        seg.add(p.second, q + 1, p.first);
    }

    vector<int> answer = seg.work();
    for (int t = 0; t <= q; t++) {
        cout << answer[t] << ' ';
    }
    cout << '\n';
}

#M Miscellaneous

@051 Ternary Search:

const long double EPS = 1e-12;
{
    long double l = -10000, r = 10000;
    while (r - l > EPS) {
        long double m = (l + r) / 2;
        if (f(m) < f(m + EPS)) {
            r = m;
        } else {
            l = m;
        }
    }
    cout << setprecision(14) << fixed << f(l) << '\n';
}

@052 Parallel Binary Search (PBS): the number of queries is n

{
    vector<array<int, 2>> qs(n);
    vector<vector<int>> inbox(k + 2);
    for (int i = 0; i < n; i++) {
        qs[i] = { 0, k + 1 }; // left and right
        inbox[(0 + k + 1) >> 1].push_back(i);
    }
    for (int ite = 0; ite < LOG; ite++) {
        Fenwick fen(m); // DS
        vector<vector<int>> new_inbox(k + 2);
        for (int mid = 0; mid <= k; mid++) {
            for (int i : inbox[mid]) {
                int &l = qs[i][0], &r = qs[i][1];
                if (ok) r = mid;
                else l = mid + 1;
                new_inbox[(l + r) >> 1].push_back(i);
            }
            if (mid < k) { // add to DS
                fen.add(showers[mid][0], showers[mid][1], showers[mid][2]);
            }
        }
        inbox = new_inbox;
    }
    // result is qs[i][0] for each i
}

@053 Harmonic Knapsack with Trace:

{
    int n;
    vector<int> initial_items(n);
    map<int, vector<vector<int>>> objects;

    for (int i = 0; i < n; i++) {
        int x = initial_items[i];
        objects[x].push_back({i});
        while (objects[x].size() == 3) {
            vector<int> vec1 = objects[x].back();
            objects[x].pop_back();
            vector<int> vec2 = objects[x].back();
            objects[x].pop_back();
            vec1.insert(vec1.end(), vec2.begin(), vec2.end());
            objects[x + x].push_back(vec1);
            x = x + x;
        }
    }

    int C; // desired size of knapsack
    vector<int> knapsack(C, -1);
    vector<vector<int>> indexes;
    vector<int> weight;
    int id = 0;

    knapsack[0] = 6785;
    for (pair<int, vector<vector<int>>> pai : objects) {
        int x = pai.first;
        vector<vector<int>> &vecs = pai.second;
        for (vector<int> vec : vecs) {
            indexes.push_back(vec);
            weight.push_back(x);
            for (int sum = C - 1; sum >= x; sum--) {
                if (knapsack[sum - x] != -1 && knapsack[sum] == -1) {
                    knapsack[sum] = id;
                }
            }
            id++;
        }
    }

    int sum; // some desired sum that the knapsack can create, knap[sum] != -1

    map<int, bool> selected;
    while (sum > 0) {
        for (int i : indexes[knapsack[sum]]) {
            selected[i] = true;
        }
        sum -= weight[knapsack[sum]];
    }
}
